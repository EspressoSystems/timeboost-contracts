/**

Generated by the following Solidity interface...
```solidity
interface KeyManager {
    struct Committee {
        uint64 id;
        uint64 effectiveTimestamp;
        uint256 registeredBlockNumber;
        CommitteeMember[] members;
    }
    struct CommitteeMember {
        bytes sigKey;
        bytes dhKey;
        bytes dkgKey;
        string networkAddress;
    }

    error AddressEmptyCode(address target);
    error CannotRemoveRecentCommittees();
    error CommitteeIdDoesNotExist(uint64 committeeId);
    error CommitteeIdOverflow();
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error EmptyCommitteeMembers();
    error FailedCall();
    error InvalidAddress();
    error InvalidEffectiveTimestamp(uint64 effectiveTimestamp, uint64 lastEffectiveTimestamp);
    error InvalidInitialization();
    error InvalidPruneRange(uint64 upToCommitteeId, uint64 oldestStored, uint64 nextCommitteeId);
    error NoCommitteeScheduled();
    error NotInitializing();
    error NotManager(address caller);
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);
    error ThresholdEncryptionKeyAlreadySet();
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);

    event CommitteeCreated(uint64 indexed id);
    event CommitteesPruned(uint64 indexed fromId, uint64 indexed toId);
    event Initialized(uint64 version);
    event ManagerChanged(address indexed oldManager, address indexed newManager);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event ThresholdEncryptionKeyUpdated(bytes thresholdEncryptionKey);
    event Upgraded(address indexed implementation);

    constructor();

    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function committees(uint64) external view returns (uint64 id, uint64 effectiveTimestamp, uint256 registeredBlockNumber);
    function currentCommitteeId() external view returns (uint64 committeeId);
    function getCommitteeById(uint64 id) external view returns (Committee memory committee);
    function initialize(address initialManager) external;
    function manager() external view returns (address);
    function nextCommitteeId() external view returns (uint64);
    function owner() external view returns (address);
    function proxiableUUID() external view returns (bytes32);
    function pruneUntil(uint64 upToCommitteeId) external;
    function renounceOwnership() external;
    function setManager(address newManager) external;
    function setNextCommittee(uint64 effectiveTimestamp, CommitteeMember[] memory members) external returns (uint64 committeeId);
    function setThresholdEncryptionKey(bytes memory newThresholdEncryptionKey) external;
    function thresholdEncryptionKey() external view returns (bytes memory);
    function transferOwnership(address newOwner) external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "committees",
    "inputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "id",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "effectiveTimestamp",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "registeredBlockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "currentCommitteeId",
    "inputs": [],
    "outputs": [
      {
        "name": "committeeId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCommitteeById",
    "inputs": [
      {
        "name": "id",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "committee",
        "type": "tuple",
        "internalType": "struct KeyManager.Committee",
        "components": [
          {
            "name": "id",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "effectiveTimestamp",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "registeredBlockNumber",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "members",
            "type": "tuple[]",
            "internalType": "struct KeyManager.CommitteeMember[]",
            "components": [
              {
                "name": "sigKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "dhKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "dkgKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "networkAddress",
                "type": "string",
                "internalType": "string"
              }
            ]
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "initialManager",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "manager",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nextCommitteeId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pruneUntil",
    "inputs": [
      {
        "name": "upToCommitteeId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setManager",
    "inputs": [
      {
        "name": "newManager",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setNextCommittee",
    "inputs": [
      {
        "name": "effectiveTimestamp",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "members",
        "type": "tuple[]",
        "internalType": "struct KeyManager.CommitteeMember[]",
        "components": [
          {
            "name": "sigKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "dhKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "dkgKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "networkAddress",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "committeeId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setThresholdEncryptionKey",
    "inputs": [
      {
        "name": "newThresholdEncryptionKey",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "thresholdEncryptionKey",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "event",
    "name": "CommitteeCreated",
    "inputs": [
      {
        "name": "id",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CommitteesPruned",
    "inputs": [
      {
        "name": "fromId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "toId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ManagerChanged",
    "inputs": [
      {
        "name": "oldManager",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newManager",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ThresholdEncryptionKeyUpdated",
    "inputs": [
      {
        "name": "thresholdEncryptionKey",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "CannotRemoveRecentCommittees",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CommitteeIdDoesNotExist",
    "inputs": [
      {
        "name": "committeeId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "CommitteeIdOverflow",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyCommitteeMembers",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidEffectiveTimestamp",
    "inputs": [
      {
        "name": "effectiveTimestamp",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "lastEffectiveTimestamp",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidPruneRange",
    "inputs": [
      {
        "name": "upToCommitteeId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "oldestStored",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "nextCommitteeId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "NoCommitteeScheduled",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotManager",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ThresholdEncryptionKeyAlreadySet",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod KeyManager {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523461003e5761001161004d565b610019610043565b61340e6102c88239608051818181612c5101528181612cb60152612e77015261340e90f35b610049565b60405190565b5f80fd5b6100556100a1565b61005d61019e565b565b60018060a01b031690565b90565b61008161007c6100869261005f565b61006a565b61005f565b90565b6100929061006d565b90565b61009e90610089565b90565b6100aa30610095565b608052565b60401c90565b60ff1690565b6100c76100cc916100af565b6100b5565b90565b6100d990546100bb565b90565b5f0190565b5f1c90565b60018060401b031690565b6100fd610102916100e1565b6100e6565b90565b61010f90546100f1565b90565b60018060401b031690565b5f1b90565b9061013360018060401b039161011d565b9181191691161790565b61015161014c61015692610112565b61006a565b610112565b90565b90565b9061017161016c6101789261013d565b610159565b8254610122565b9055565b61018590610112565b9052565b919061019c905f6020850194019061017c565b565b6101a6610256565b6101b15f82016100cf565b61023a576101c05f8201610105565b6101d86101d260018060401b03610112565b91610112565b036101e1575b50565b6101f4905f60018060401b03910161015c565b60018060401b036102317fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d291610228610043565b91829182610189565b0390a15f6101de565b5f63f92ee8a960e01b815280610252600482016100dc565b0390fd5b61025e6102b3565b90565b5f90565b90565b90565b61027f61027a61028492610265565b61011d565b610268565b90565b6102b07ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0061026b565b90565b6102bb610261565b506102c4610287565b9056fe60806040526004361015610013575b610e19565b61001d5f3561012c565b80630f1569cb1461012757806328ce469214610122578063481c6a751461011d5780634f1ef2861461011857806352d1902d146101135780635b3d1f0a1461010e57806369f8bfa814610109578063715018a614610104578063824cd9f8146100ff5780638da5cb5b146100fa578063ad3cb1cc146100f5578063c4d66de8146100f0578063d00d5a5c146100eb578063d0ebdbe7146100e6578063e5b51606146100e1578063f2fde38b146100dc5763f84067660361000e57610de5565b610d3d565b610d0a565b610cd7565b610ca2565b610ae2565b610a8f565b61096d565b610938565b610712565b6106da565b61056d565b610488565b610439565b6102a8565b6101fa565b61017e565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261014a57565b61013c565b67ffffffffffffffff1690565b6101659061014f565b9052565b919061017c905f6020850194019061015c565b565b346101ae5761018e366004610140565b6101aa610199610efd565b6101a1610132565b91829182610169565b0390f35b610138565b1c90565b67ffffffffffffffff1690565b6101d49060086101d993026101b3565b6101b7565b90565b906101e791546101c4565b90565b6101f760026014906101dc565b90565b3461022a5761020a366004610140565b6102266102156101ea565b61021d610132565b91829182610169565b0390f35b610138565b60018060a01b031690565b61024a90600861024f93026101b3565b61022f565b90565b9061025d915461023a565b90565b61026c60025f90610252565b90565b60018060a01b031690565b6102839061026f565b90565b61028f9061027a565b9052565b91906102a6905f60208501940190610286565b565b346102d8576102b8366004610140565b6102d46102c3610260565b6102cb610132565b91829182610293565b0390f35b610138565b5f80fd5b6102ea8161027a565b036102f157565b5f80fd5b90503590610302826102e1565b565b5f80fd5b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906103349061030c565b810190811067ffffffffffffffff82111761034e57604052565b610316565b9061036661035f610132565b928361032a565b565b67ffffffffffffffff81116103865761038260209161030c565b0190565b610316565b90825f939282370152565b909291926103ab6103a682610368565b610353565b938185526020850190828401116103c7576103c59261038b565b565b610308565b9080601f830112156103ea578160206103e793359101610396565b90565b610304565b91909160408184031261042f57610408835f83016102f5565b92602082013567ffffffffffffffff811161042a5761042792016103cc565b90565b6102dd565b61013c565b5f0190565b61044d6104473660046103ef565b9061106b565b610455610132565b8061045f81610434565b0390f35b90565b61046f90610463565b9052565b9190610486905f60208501940190610466565b565b346104b857610498366004610140565b6104b46104a36110eb565b6104ab610132565b91829182610473565b0390f35b610138565b6104c68161014f565b036104cd57565b5f80fd5b905035906104de826104bd565b565b5f80fd5b5f80fd5b909182601f830112156105225781359167ffffffffffffffff831161051d57602001926020830284011161051857565b6104e4565b6104e0565b610304565b91909160408184031261056857610540835f83016104d1565b92602082013567ffffffffffffffff81116105635761055f92016104e8565b9091565b6102dd565b61013c565b3461059e5761059a610589610583366004610527565b91611faf565b610591610132565b91829182610169565b0390f35b610138565b906020828203126105bc576105b9915f016104d1565b90565b61013c565b90565b6105d86105d36105dd9261014f565b6105c1565b61014f565b90565b906105ea906105c4565b5f5260205260405f2090565b5f1c90565b61060761060c916105f6565b6101b7565b90565b61061990546105fb565b90565b60401c90565b61062e6106339161061c565b6101b7565b90565b6106409054610622565b90565b90565b610652610657916105f6565b610643565b90565b6106649054610646565b90565b6106729060016105e0565b61067d5f820161060f565b91610695600161068e5f8501610636565b930161065a565b90565b90565b6106a490610698565b9052565b6040906106d16106d894969593966106c760608401985f85019061015c565b602083019061015c565b019061069b565b565b3461070d576107096106f56106f03660046105a3565b610667565b610700939193610132565b938493846106a8565b0390f35b610138565b3461074057610722366004610140565b61072a612012565b610732610132565b8061073c81610434565b0390f35b610138565b61074e9061014f565b9052565b61075b90610698565b9052565b5190565b60209181520190565b60200190565b5190565b60209181520190565b90825f9392825e0152565b6107a96107b26020936107b7936107a081610772565b93848093610776565b9586910161077f565b61030c565b0190565b5190565b60209181520190565b6107e76107f06020936107f5936107de816107bb565b938480936107bf565b9586910161077f565b61030c565b0190565b61085191606061084061082e61081c608085015f8701518682035f88015261078a565b6020860151858203602087015261078a565b6040850151848203604086015261078a565b9201519060608184039101526107c8565b90565b9061085e916107f9565b90565b60200190565b9061087b6108748361075f565b8092610763565b908161088c6020830284019461076c565b925f915b83831061089f57505050505090565b909192939460206108c16108bb83856001950387528951610854565b97610861565b9301930191939290610890565b61091d91606060808201926108e95f8201515f850190610745565b6108fb60208201516020850190610745565b61090d60408201516040850190610752565b0151906060818403910152610867565b90565b6109359160208201915f8184039101526108ce565b90565b346109685761096461095361094e3660046105a3565b61229c565b61095b610132565b91829182610920565b0390f35b610138565b3461099d5761097d366004610140565b610999610988612357565b610990610132565b91829182610293565b0390f35b610138565b67ffffffffffffffff81116109c0576109bc60209161030c565b0190565b610316565b906109d76109d2836109a2565b610353565b918252565b5f7f352e302e30000000000000000000000000000000000000000000000000000000910152565b610a0d60056109c5565b90610a1a602083016109dc565b565b610a24610a03565b90565b610a2f610a1c565b90565b610a3a610a27565b90565b60209181520190565b610a65610a6e602093610a7393610a5c816107bb565b93848093610a3d565b9586910161077f565b61030c565b0190565b610a8c9160208201915f818403910152610a46565b90565b34610abf57610a9f366004610140565b610abb610aaa610a32565b610ab2610132565b91829182610a77565b0390f35b610138565b90602082820312610add57610ada915f016102f5565b90565b61013c565b34610b1057610afa610af5366004610ac4565b612645565b610b02610132565b80610b0c81610434565b0390f35b610138565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610b5c575b6020831014610b5757565b610b28565b91607f1691610b4c565b5f5260205f2090565b905f9291805490610b89610b8283610b3c565b8094610776565b916001811690815f14610be05750600114610ba4575b505050565b610bb19192939450610b66565b915f925b818410610bc857505001905f8080610b9f565b60018160209295939554848601520191019290610bb5565b92949550505060ff19168252151560200201905f8080610b9f565b90610c0591610b6f565b90565b90610c28610c2192610c18610132565b93848092610bfb565b038361032a565b565b905f10610c3d57610c3a90610c08565b90565b610b15565b610c4d5f5f90610c2a565b90565b60209181520190565b610c78610c81602093610c8693610c6f81610772565b93848093610c50565b9586910161077f565b61030c565b0190565b610c9f9160208201915f818403910152610c59565b90565b34610cd257610cb2366004610140565b610cce610cbd610c42565b610cc5610132565b91829182610c8a565b0390f35b610138565b34610d0557610cef610cea366004610ac4565b61272a565b610cf7610132565b80610d0181610434565b0390f35b610138565b34610d3857610d22610d1d3660046105a3565b6129eb565b610d2a610132565b80610d3481610434565b0390f35b610138565b34610d6b57610d55610d50366004610ac4565b612a5b565b610d5d610132565b80610d6781610434565b0390f35b610138565b909182601f83011215610daa5781359167ffffffffffffffff8311610da5576020019260018302840111610da057565b6104e4565b6104e0565b610304565b90602082820312610de0575f82013567ffffffffffffffff8111610ddb57610dd79201610d70565b9091565b6102dd565b61013c565b34610e1457610dfe610df8366004610daf565b90612c28565b610e06610132565b80610e1081610434565b0390f35b610138565b5f80fd5b5f90565b610e35610e30610e3a92610698565b6105c1565b61014f565b90565b60a01c90565b610e4f610e5491610e3d565b6101b7565b90565b610e619054610e43565b90565b90565b610e7b610e76610e8092610e64565b6105c1565b61014f565b90565b90565b610e9a610e95610e9f92610e83565b6105c1565b61014f565b90565b634e487b7160e01b5f52601160045260245ffd5b610ec2610ec89161014f565b9161014f565b90039067ffffffffffffffff8211610edc57565b610ea2565b610eea9061014f565b5f8114610ef8576001900390565b610ea2565b610f05610e1d565b50610f0f42610e21565b90610f1a6002610e57565b610f2c610f265f610e67565b9161014f565b148015611015575b610ff957610f55610f456002610e57565b610f4f6001610e86565b90610eb6565b5b80610f72610f6c610f67600361060f565b61014f565b9161014f565b10610ff15782610f9f610f99610f945f610f8e600187906105e0565b01610636565b61014f565b9161014f565b1015610feb5780610fb8610fb25f610e67565b9161014f565b14610fcb57610fc690610ee1565b610f56565b5050505b5f6323788e8160e01b815280610fe760048201610434565b0390fd5b90915090565b505050610fcf565b5f6323788e8160e01b81528061101160048201610434565b0390fd5b50611020600361060f565b61103b6110356110306002610e57565b61014f565b9161014f565b1015610f34565b906110549161104f612c40565b611056565b565b906110699161106481612cf2565b612d68565b565b9061107591611042565b565b5f90565b61108c90611087612e66565b6110df565b90565b90565b5f1b90565b6110ab6110a66110b09261108f565b611092565b610463565b90565b6110dc7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc611097565b90565b506110e86110b3565b90565b6110fb6110f6611077565b61107b565b90565b9061111293929161110d612ec4565b611d8e565b90565b5090565b61112d61112861113292610e64565b6105c1565b610698565b90565b91602061115692949361114f60408201965f83019061015c565b019061015c565b565b6111626080610353565b90565b9061116f9061014f565b9052565b9061117d90610698565b9052565b67ffffffffffffffff81116111995760208091020190565b610316565b5f80fd5b5f80fd5b909291926111bb6111b6826109a2565b610353565b938185526020850190828401116111d7576111d59261038b565b565b610308565b9080601f830112156111fa578160206111f7933591016111a6565b90565b610304565b9190916080818403126112bd576112166080610353565b925f82013567ffffffffffffffff81116112b857816112369184016103cc565b5f850152602082013567ffffffffffffffff81116112b3578161125a9184016103cc565b6020850152604082013567ffffffffffffffff81116112ae578161127f9184016103cc565b6040850152606082013567ffffffffffffffff81116112a9576112a292016111dc565b6060830152565b6111a2565b6111a2565b6111a2565b6111a2565b61119e565b9291906112d66112d182611181565b610353565b938185526020808601920281019183831161132d5781905b8382106112fc575050505050565b813567ffffffffffffffff81116113285760209161131d87849387016111ff565b8152019101906112ee565b610304565b6104e4565b61133d9136916112c2565b90565b52565b61134d905161014f565b90565b9061136367ffffffffffffffff91611092565b9181191691161790565b90565b9061138561138061138c926105c4565b61136d565b8254611350565b9055565b60401b90565b906113b16fffffffffffffffff000000000000000091611390565b9181191691161790565b906113d06113cb6113d7926105c4565b61136d565b8254611396565b9055565b6113e59051610698565b90565b906113f45f1991611092565b9181191691161790565b61141261140d61141792610698565b6105c1565b610698565b90565b90565b9061143261142d611439926113fe565b61141a565b82546113e8565b9055565b5190565b5490565b61145461145a91939293610698565b92610698565b91611466838202610698565b92818404149015171561147557565b610ea2565b611485906004611445565b90565b5f5260205f2090565b906114a4905f19906020036008026101b3565b8154169055565b1b90565b919060086114ca9102916114c45f19846114ab565b926114ab565b9181191691161790565b91906114ea6114e56114f2936113fe565b61141a565b9083546114af565b9055565b5f90565b61150c916115066114f6565b916114d4565b565b5b81811061151a575050565b806115275f6001936114fa565b0161150f565b9061153d905f19906008026101b3565b191690565b8161154c9161152d565b906002021790565b905f9161156b61156382610b66565b928354611542565b905555565b601f602091010490565b919290602082105f146115d357601f84116001146115a35761159d929350611542565b90555b5b565b50906115c96115ce9360016115c06115ba85610b66565b92611570565b8201910161150e565b611554565b6115a0565b5061160a82936115e4600194610b66565b6116036115f085611570565b820192601f861680611615575b50611570565b019061150e565b6002021790556115a1565b61162190888603611491565b5f6115fd565b929091680100000000000000008211611687576020115f1461167857602081105f1461165c5761165691611542565b90555b5b565b60019160ff191661166c84610b66565b55600202019055611659565b6001915060020201905561165a565b610316565b90815461169881610b3c565b908183116116c1575b8183106116af575b50505050565b6116b89361157a565b5f8080806116a9565b6116cd83838387611627565b6116a1565b5f6116dc9161168c565b565b905f036116f0576116ee906116d2565b565b610b15565b5f5260205f2090565b905f9161171561170d826116f5565b928354611542565b905555565b919290602082105f1461177357601f84116001146117435761173d929350611542565b90555b5b565b509061176961176e93600161176061175a856116f5565b92611570565b8201910161150e565b6116fe565b611740565b506117aa82936117846001946116f5565b6117a361179085611570565b820192601f8616806117b5575b50611570565b019061150e565b600202179055611741565b6117c190888603611491565b5f61179d565b929091680100000000000000008211611827576020115f1461181857602081105f146117fc576117f691611542565b90555b5b565b60019160ff191661180c846116f5565b556002020190556117f9565b600191506002020190556117fa565b610316565b90815461183881610b3c565b90818311611861575b81831061184f575b50505050565b6118589361171a565b5f808080611849565b61186d838383876117c7565b611841565b5f61187c9161182c565b565b905f036118905761188e90611872565b565b610b15565b5f60036118c8926118a8838083016116de565b6118b583600183016116de565b6118c283600283016116de565b0161187e565b565b905f036118dc576118da90611895565b565b610b15565b5b8181106118ed575050565b806118fa5f6004936118ca565b016118e2565b909182811061190f575b505050565b61192d6119276119216119389561147a565b9261147a565b92611488565b9182019101906118e1565b5f808061190a565b90680100000000000000008111611969578161195e61196793611441565b90828155611900565b565b610316565b5190565b5190565b9190601f8111611986575b505050565b6119926119b793610b66565b90602061199e84611570565b830193106119bf575b6119b090611570565b019061150e565b5f8080611981565b91506119b0819290506119a7565b906119d781610772565b9067ffffffffffffffff8211611a97576119fb826119f58554610b3c565b85611976565b602090601f8311600114611a2f57918091611a1e935f92611a23575b5050611542565b90555b565b90915001515f80611a17565b601f19831691611a3e85610b66565b925f5b818110611a7f57509160029391856001969410611a65575b50505002019055611a21565b611a75910151601f84169061152d565b90555f8080611a59565b91936020600181928787015181550195019201611a41565b610316565b90611aa6916119cd565b565b5190565b9190601f8111611abc575b505050565b611ac8611aed936116f5565b906020611ad484611570565b83019310611af5575b611ae690611570565b019061150e565b5f8080611ab7565b9150611ae681929050611add565b90611b0d816107bb565b9067ffffffffffffffff8211611bcd57611b3182611b2b8554610b3c565b85611aac565b602090601f8311600114611b6557918091611b54935f92611b59575b5050611542565b90555b565b90915001515f80611b4d565b601f19831691611b74856116f5565b925f5b818110611bb557509160029391856001969410611b9b575b50505002019055611b57565b611bab910151601f84169061152d565b90555f8080611b8f565b91936020600181928787015181550195019201611b77565b610316565b90611bdc91611b03565b565b90611c3b60606003611c4194611c015f8201611bfb5f8801611972565b90611a9c565b611c1a60018201611c1460208801611972565b90611a9c565b611c3360028201611c2d60408801611972565b90611a9c565b019201611aa8565b90611bd2565b565b90611c4d91611bde565b565b611c74611c6e611c5e8461075f565b93611c698585611940565b61076c565b91611488565b5f915b838310611c845750505050565b6004602082611c9d611c9760019561196e565b86611c43565b01920192019190611c77565b90611cb391611c4f565b565b90611d1160606002611d1794611cd85f8201611cd25f8801611343565b90611370565b611cf05f8201611cea60208801611343565b906113bb565b611d0960018201611d03604088016113db565b9061141d565b01920161143d565b90611ca9565b565b90611d2391611cb5565b565b611d2e9061014f565b67ffffffffffffffff8114611d435760010190565b610ea2565b60a01b90565b90611d6467ffffffffffffffff60a01b91611d48565b9181191691161790565b90611d83611d7e611d8a926105c4565b61136d565b8254611d4e565b9055565b91909150611d9d818490611115565b611daf611da95f611119565b91610698565b14611f9357611dbe6002610e57565b611dd0611dca5f610e67565b9161014f565b11611f23575b611de06002610e57565b611dfa611df467ffffffffffffffff61014f565b9161014f565b14611f0757611e4b611e5491611e6e94611e46611e176002610e57565b9592611e3d43919394611e34611e2b611158565b995f8b01611165565b60208901611165565b60408701611173565b611332565b60608301611340565b611e696001611e636002610e57565b906105e0565b611d19565b611e8a611e83611e7e6002610e57565b611d25565b6002611d6e565b611ea7611e976002610e57565b611ea16001610e86565b90610eb6565b611ed17f150aea6b58abe43dc5a19b4c738e682611cb0f8265b89f6d3ff64e100d84777f916105c4565b90611eda610132565b80611ee481610434565b0390a2611f04611ef46002610e57565b611efe6001610e86565b90610eb6565b90565b5f630115b11160e71b815280611f1f60048201610434565b0390fd5b611f555f611f4f6001611f49611f396002610e57565b611f436001610e86565b90610eb6565b906105e0565b01610636565b82611f68611f628361014f565b9161014f565b1115611f745750611dd6565b82611f8f5f92839263eaf639e560e01b845260048401611135565b0390fd5b5f63283601e960e21b815280611fab60048201610434565b0390fd5b90611fc29291611fbd610e1d565b6110fe565b90565b611fcd612f06565b611fd5611fff565b565b611feb611fe6611ff092610e64565b6105c1565b61026f565b90565b611ffc90611fd7565b90565b61201061200b5f611ff3565b612f54565b565b61201a611fc5565b565b6120266080610353565b90565b5f90565b5f90565b606090565b61203e61201c565b9060208080808561204d612029565b815201612058612029565b81520161206361202d565b81520161206e612031565b81525050565b61207c612036565b90565b9061209161208c83611181565b610353565b918252565b52565b905f92918054906120b36120ac83610b3c565b80946107bf565b916001811690815f1461210a57506001146120ce575b505050565b6120db91929394506116f5565b915f925b8184106120f257505001905f80806120c9565b600181602092959395548486015201910192906120df565b92949550505060ff19168252151560200201905f80806120c9565b9061212f91612099565b90565b9061215261214b92612142610132565b93848092612125565b038361032a565b565b52565b6121616080610353565b90565b906121cb6121c26003612175612157565b9461218c6121845f8301610c08565b5f8801612096565b6121a461219b60018301610c08565b60208801612096565b6121bc6121b360028301610c08565b60408801612096565b01612132565b60608401612154565b565b6121d690612164565b90565b906121e382611441565b6121ec8161207f565b926121fa6020850191611488565b5f915b83831061220a5750505050565b6004602060019261221a856121cd565b8152019201920191906121fd565b9061228e612285600261223961201c565b946122506122485f830161060f565b5f8801611165565b61226761225e5f8301610636565b60208801611165565b61227f6122766001830161065a565b60408801611173565b016121d9565b60608401611340565b565b61229990612228565b90565b6122a4612074565b50806122c16122bb6122b6600361060f565b61014f565b9161014f565b108015612302575b6122e3576122db6122e09160016105e0565b612290565b90565b6122fe905f918291637844813360e01b835260048301610169565b0390fd5b506123195f612313600184906105e0565b0161060f565b61232b6123258361014f565b9161014f565b14156122c9565b5f90565b612342612347916105f6565b61022f565b90565b6123549054612336565b90565b61235f612332565b506123725f61236c612fc0565b0161234a565b90565b60ff1690565b61238761238c9161061c565b612375565b90565b612399905461237b565b90565b151590565b6123b56123b06123ba9261026f565b6105c1565b61026f565b90565b6123c6906123a1565b90565b6123d2906123bd565b90565b906123e968ff000000000000000091611390565b9181191691161790565b6123fc9061239c565b90565b90565b9061241761241261241e926123f3565b6123ff565b82546123d5565b9055565b61242b90610e86565b9052565b9190612442905f60208501940190612422565b565b61244c612fe4565b9061246161245b5f840161238f565b1561239c565b9061246d5f840161060f565b8061248061247a5f610e67565b9161014f565b148061259a575b9061249b6124956001610e86565b9161014f565b1480612572575b6124ad90911561239c565b9081612561575b50612545576124dd906124d26124ca6001610e86565b5f8601611370565b82612533575b6125eb565b6124e5575b50565b6124f2905f809101612402565b600161252a7fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d291612521610132565b9182918261242f565b0390a15f6124e2565b61254060015f8601612402565b6124d8565b5f63f92ee8a960e01b81528061255d60048201610434565b0390fd5b61256c91501561239c565b5f6124b4565b506124ad61257f306123c9565b3b61259261258c5f611119565b91610698565b1490506124a2565b5082612487565b906125b260018060a01b0391611092565b9181191691161790565b6125c5906123bd565b90565b90565b906125e06125db6125e7926125bc565b6125c8565b82546125a1565b9055565b806126066126006125fb5f611ff3565b61027a565b9161027a565b1461262957612627906126183361300d565b612620613022565b60026125cb565b565b5f63e6c4247b60e01b81528061264160048201610434565b0390fd5b61264e90612444565b565b6126619061265c612f06565b612663565b565b8061267e6126786126735f611ff3565b61027a565b9161027a565b148015612707575b6126eb57612694600261234a565b61269f8260026125cb565b906126d36126cd7f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a4350936125bc565b916125bc565b916126dc610132565b806126e681610434565b0390a3565b5f63e6c4247b60e01b81528061270360048201610434565b0390fd5b508061272461271e612719600261234a565b61027a565b9161027a565b14612686565b61273390612650565b565b61274690612741612ec4565b612843565b565b604090612771612778949695939661276760608401985f85019061015c565b602083019061015c565b019061015c565b565b90565b61279161278c6127969261277a565b6105c1565b610698565b90565b6127a86127ae91939293610698565b92610698565b82039182116127b957565b610ea2565b5f6127c891611940565b565b905f036127dc576127da906127be565b565b610b15565b5f60026128009282808201556127fa83600183016114fa565b016127ca565b565b905f0361281457612812906127e1565b565b610b15565b61282561282b9161014f565b9161014f565b019067ffffffffffffffff821161283e57565b610ea2565b908161286061285a612855600361060f565b61014f565b9161014f565b1080156129c7575b612993576128896128844261287e61025861277d565b90612799565b610e21565b90612894600361060f565b9261289f600361060f565b5b806128b36128ad8461014f565b9161014f565b11612925576128ce5f6128c8600184906105e0565b01610636565b6128e06128da8661014f565b9161014f565b101561290957612904906128ff5f6128fa600184906105e0565b612802565b611d25565b6128a0565b5f6375b942bb60e01b81528061292160048201610434565b0390fd5b509150916129476129408361293a6001610e86565b90612819565b6003611370565b9061297b6129757fe9050b7442eb674ed5ec7aa7e21455f8b7344e407385c1a810e4ab5c2a0ed8a2936105c4565b916105c4565b91612984610132565b8061298e81610434565b0390a3565b5061299e600361060f565b906129c36129ac6002610e57565b5f93849363190e9f4b60e11b855260048501612748565b0390fd5b50816129e46129de6129d96002610e57565b61014f565b9161014f565b1015612868565b6129f490612735565b565b612a0790612a02612f06565b612a09565b565b80612a24612a1e612a195f611ff3565b61027a565b9161027a565b14612a3457612a3290612f54565b565b612a57612a405f611ff3565b5f918291631e4fbdf760e01b835260048301610293565b0390fd5b612a64906129f6565b565b90612a7891612a73612ec4565b612ba4565b565b612a849054610b3c565b90565b5090565b91612a969082612a87565b9067ffffffffffffffff8211612b5557612aba82612ab48554610b3c565b85611976565b5f90601f8311600114612aed57918091612adc935f92612ae1575b5050611542565b90555b565b90915001355f80612ad5565b601f19831691612afc85610b66565b925f5b818110612b3d57509160029391856001969410612b23575b50505002019055612adf565b612b33910135601f84169061152d565b90555f8080612b17565b91936020600181928787013581550195019201612aff565b610316565b90612b659291612a8b565b565b9190612b8181612b7a81612b8695610c50565b809561038b565b61030c565b0190565b9091612ba19260208301925f818503910152612b67565b90565b612bad5f612a7a565b612bbf612bb95f611119565b91610698565b11612c0c57612bd08183905f612b5a565b907f54482048e83dca0280310b341d9acf236ac8b0ae105dc9621db5715f683a22e791612c07612bfe610132565b92839283612b8a565b0390a1565b5f637e8a432b60e01b815280612c2460048201610434565b0390fd5b90612c3291612a66565b565b612c3d906123bd565b90565b612c4930612c34565b612c7b612c757f000000000000000000000000000000000000000000000000000000000000000061027a565b9161027a565b148015612ca5575b612c8957565b5f63703e46dd60e11b815280612ca160048201610434565b0390fd5b50612cae61302c565b612ce0612cda7f000000000000000000000000000000000000000000000000000000000000000061027a565b9161027a565b1415612c83565b50612cf0612f06565b565b612cfb90612ce7565b565b612d06906123a1565b90565b612d1290612cfd565b90565b612d1e906123bd565b90565b60e01b90565b612d3081610463565b03612d3757565b5f80fd5b90505190612d4882612d27565b565b90602082820312612d6357612d60915f01612d3b565b90565b61013c565b9190612d966020612d80612d7b86612d09565b612d15565b6352d1902d90612d8e610132565b938492612d21565b82528180612da660048201610434565b03915afa80915f92612e36575b50155f14612de7575050906001612dc857505b565b612de3905f918291634c9c8ce360e01b835260048301610293565b0390fd5b9283612e02612dfc612df76110b3565b610463565b91610463565b03612e1757612e12929350613052565b612dc6565b612e32845f918291632a87526960e21b835260048301610473565b0390fd5b612e5891925060203d8111612e5f575b612e50818361032a565b810190612d4a565b905f612db3565b503d612e46565b612e6f30612c34565b612ea1612e9b7f000000000000000000000000000000000000000000000000000000000000000061027a565b9161027a565b03612ea857565b5f63703e46dd60e11b815280612ec060048201610434565b0390fd5b33612ee0612eda612ed5600261234a565b61027a565b9161027a565b03612ee757565b612f02335f918291632a19e83360e01b835260048301610293565b0390fd5b612f0e612357565b612f27612f21612f1c6130db565b61027a565b9161027a565b03612f2e57565b612f50612f396130db565b5f91829163118cdaa760e01b835260048301610293565b0390fd5b612f5c612fc0565b612f74612f6a5f830161234a565b915f8491016125cb565b90612fa8612fa27f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0936125bc565b916125bc565b91612fb1610132565b80612fbb81610434565b0390a3565b7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930090565b612fec613133565b90565b61300090612ffb613147565b613002565b565b61300b906131df565b565b61301690612fef565b565b613020613147565b565b61302a613018565b565b613034612332565b5061304f5f6130496130446110b3565b6131ea565b0161234a565b90565b9061305c826131ed565b816130877fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b916125bc565b90613090610132565b8061309a81610434565b0390a26130a681610772565b6130b86130b25f611119565b91610698565b115f146130cc576130c8916132bd565b505b565b50506130d6613242565b6130ca565b6130e3612332565b503390565b90565b6130ff6130fa613104926130e8565b611092565b610463565b90565b6131307ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a006130eb565b90565b61313b611077565b50613144613107565b90565b6131586131526132f0565b1561239c565b61315e57565b5f631afcd79f60e31b81528061317660048201610434565b0390fd5b61318b90613186613147565b61318d565b565b806131a86131a261319d5f611ff3565b61027a565b9161027a565b146131b8576131b690612f54565b565b6131db6131c45f611ff3565b5f918291631e4fbdf760e01b835260048301610293565b0390fd5b6131e89061317a565b565b90565b803b6132016131fb5f611119565b91610698565b1461322357613221905f61321b6132166110b3565b6131ea565b016125cb565b565b61323e905f918291634c9c8ce360e01b835260048301610293565b0390fd5b3461325561324f5f611119565b91610698565b1161325c57565b5f63b398979f60e01b81528061327460048201610434565b0390fd5b606090565b9061328f61328a83610368565b610353565b918252565b3d5f146132af576132a43d61327d565b903d5f602084013e5b565b6132b7613278565b906132ad565b5f806132e9936132cb613278565b508390602081019051915af4906132e0613294565b9091909161330e565b90565b5f90565b6132f86132ec565b5061330b5f613305612fe4565b0161238f565b90565b906133229061331b613278565b501561239c565b5f1461332e5750613392565b61333782610772565b6133496133435f611119565b91610698565b1480613377575b613358575090565b613373905f918291639996b31560e01b835260048301610293565b0390fd5b50803b61338c6133865f611119565b91610698565b14613350565b61339b81610772565b6133ad6133a75f611119565b91610698565b115f146133bc57602081519101fd5b5f63d6bda27560e01b8152806133d460048201610434565b0390fdfea26469706673582212207833e93a77992454daeb7cc9bec9049b4568617b60ce396a8f79d99c7cf591b764736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R4a\0>Wa\0\x11a\0MV[a\0\x19a\0CV[a4\x0Ea\x02\xC8\x829`\x80Q\x81\x81\x81a,Q\x01R\x81\x81a,\xB6\x01Ra.w\x01Ra4\x0E\x90\xF3[a\0IV[`@Q\x90V[_\x80\xFD[a\0Ua\0\xA1V[a\0]a\x01\x9EV[V[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\0\x81a\0|a\0\x86\x92a\0_V[a\0jV[a\0_V[\x90V[a\0\x92\x90a\0mV[\x90V[a\0\x9E\x90a\0\x89V[\x90V[a\0\xAA0a\0\x95V[`\x80RV[`@\x1C\x90V[`\xFF\x16\x90V[a\0\xC7a\0\xCC\x91a\0\xAFV[a\0\xB5V[\x90V[a\0\xD9\x90Ta\0\xBBV[\x90V[_\x01\x90V[_\x1C\x90V[`\x01\x80`@\x1B\x03\x16\x90V[a\0\xFDa\x01\x02\x91a\0\xE1V[a\0\xE6V[\x90V[a\x01\x0F\x90Ta\0\xF1V[\x90V[`\x01\x80`@\x1B\x03\x16\x90V[_\x1B\x90V[\x90a\x013`\x01\x80`@\x1B\x03\x91a\x01\x1DV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x01Qa\x01La\x01V\x92a\x01\x12V[a\0jV[a\x01\x12V[\x90V[\x90V[\x90a\x01qa\x01la\x01x\x92a\x01=V[a\x01YV[\x82Ta\x01\"V[\x90UV[a\x01\x85\x90a\x01\x12V[\x90RV[\x91\x90a\x01\x9C\x90_` \x85\x01\x94\x01\x90a\x01|V[V[a\x01\xA6a\x02VV[a\x01\xB1_\x82\x01a\0\xCFV[a\x02:Wa\x01\xC0_\x82\x01a\x01\x05V[a\x01\xD8a\x01\xD2`\x01\x80`@\x1B\x03a\x01\x12V[\x91a\x01\x12V[\x03a\x01\xE1W[PV[a\x01\xF4\x90_`\x01\x80`@\x1B\x03\x91\x01a\x01\\V[`\x01\x80`@\x1B\x03a\x021\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x91a\x02(a\0CV[\x91\x82\x91\x82a\x01\x89V[\x03\x90\xA1_a\x01\xDEV[_c\xF9.\xE8\xA9`\xE0\x1B\x81R\x80a\x02R`\x04\x82\x01a\0\xDCV[\x03\x90\xFD[a\x02^a\x02\xB3V[\x90V[_\x90V[\x90V[\x90V[a\x02\x7Fa\x02za\x02\x84\x92a\x02eV[a\x01\x1DV[a\x02hV[\x90V[a\x02\xB0\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0a\x02kV[\x90V[a\x02\xBBa\x02aV[Pa\x02\xC4a\x02\x87V[\x90V\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x0E\x19V[a\0\x1D_5a\x01,V[\x80c\x0F\x15i\xCB\x14a\x01'W\x80c(\xCEF\x92\x14a\x01\"W\x80cH\x1Cju\x14a\x01\x1DW\x80cO\x1E\xF2\x86\x14a\x01\x18W\x80cR\xD1\x90-\x14a\x01\x13W\x80c[=\x1F\n\x14a\x01\x0EW\x80ci\xF8\xBF\xA8\x14a\x01\tW\x80cqP\x18\xA6\x14a\x01\x04W\x80c\x82L\xD9\xF8\x14a\0\xFFW\x80c\x8D\xA5\xCB[\x14a\0\xFAW\x80c\xAD<\xB1\xCC\x14a\0\xF5W\x80c\xC4\xD6m\xE8\x14a\0\xF0W\x80c\xD0\rZ\\\x14a\0\xEBW\x80c\xD0\xEB\xDB\xE7\x14a\0\xE6W\x80c\xE5\xB5\x16\x06\x14a\0\xE1W\x80c\xF2\xFD\xE3\x8B\x14a\0\xDCWc\xF8@gf\x03a\0\x0EWa\r\xE5V[a\r=V[a\r\nV[a\x0C\xD7V[a\x0C\xA2V[a\n\xE2V[a\n\x8FV[a\tmV[a\t8V[a\x07\x12V[a\x06\xDAV[a\x05mV[a\x04\x88V[a\x049V[a\x02\xA8V[a\x01\xFAV[a\x01~V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\x01JWV[a\x01<V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x01e\x90a\x01OV[\x90RV[\x91\x90a\x01|\x90_` \x85\x01\x94\x01\x90a\x01\\V[V[4a\x01\xAEWa\x01\x8E6`\x04a\x01@V[a\x01\xAAa\x01\x99a\x0E\xFDV[a\x01\xA1a\x012V[\x91\x82\x91\x82a\x01iV[\x03\x90\xF3[a\x018V[\x1C\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x01\xD4\x90`\x08a\x01\xD9\x93\x02a\x01\xB3V[a\x01\xB7V[\x90V[\x90a\x01\xE7\x91Ta\x01\xC4V[\x90V[a\x01\xF7`\x02`\x14\x90a\x01\xDCV[\x90V[4a\x02*Wa\x02\n6`\x04a\x01@V[a\x02&a\x02\x15a\x01\xEAV[a\x02\x1Da\x012V[\x91\x82\x91\x82a\x01iV[\x03\x90\xF3[a\x018V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x02J\x90`\x08a\x02O\x93\x02a\x01\xB3V[a\x02/V[\x90V[\x90a\x02]\x91Ta\x02:V[\x90V[a\x02l`\x02_\x90a\x02RV[\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x02\x83\x90a\x02oV[\x90V[a\x02\x8F\x90a\x02zV[\x90RV[\x91\x90a\x02\xA6\x90_` \x85\x01\x94\x01\x90a\x02\x86V[V[4a\x02\xD8Wa\x02\xB86`\x04a\x01@V[a\x02\xD4a\x02\xC3a\x02`V[a\x02\xCBa\x012V[\x91\x82\x91\x82a\x02\x93V[\x03\x90\xF3[a\x018V[_\x80\xFD[a\x02\xEA\x81a\x02zV[\x03a\x02\xF1WV[_\x80\xFD[\x90P5\x90a\x03\x02\x82a\x02\xE1V[V[_\x80\xFD[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x034\x90a\x03\x0CV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x03NW`@RV[a\x03\x16V[\x90a\x03fa\x03_a\x012V[\x92\x83a\x03*V[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03\x86Wa\x03\x82` \x91a\x03\x0CV[\x01\x90V[a\x03\x16V[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a\x03\xABa\x03\xA6\x82a\x03hV[a\x03SV[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x03\xC7Wa\x03\xC5\x92a\x03\x8BV[V[a\x03\x08V[\x90\x80`\x1F\x83\x01\x12\x15a\x03\xEAW\x81` a\x03\xE7\x935\x91\x01a\x03\x96V[\x90V[a\x03\x04V[\x91\x90\x91`@\x81\x84\x03\x12a\x04/Wa\x04\x08\x83_\x83\x01a\x02\xF5V[\x92` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04*Wa\x04'\x92\x01a\x03\xCCV[\x90V[a\x02\xDDV[a\x01<V[_\x01\x90V[a\x04Ma\x04G6`\x04a\x03\xEFV[\x90a\x10kV[a\x04Ua\x012V[\x80a\x04_\x81a\x044V[\x03\x90\xF3[\x90V[a\x04o\x90a\x04cV[\x90RV[\x91\x90a\x04\x86\x90_` \x85\x01\x94\x01\x90a\x04fV[V[4a\x04\xB8Wa\x04\x986`\x04a\x01@V[a\x04\xB4a\x04\xA3a\x10\xEBV[a\x04\xABa\x012V[\x91\x82\x91\x82a\x04sV[\x03\x90\xF3[a\x018V[a\x04\xC6\x81a\x01OV[\x03a\x04\xCDWV[_\x80\xFD[\x90P5\x90a\x04\xDE\x82a\x04\xBDV[V[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x05\"W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x05\x1DW` \x01\x92` \x83\x02\x84\x01\x11a\x05\x18WV[a\x04\xE4V[a\x04\xE0V[a\x03\x04V[\x91\x90\x91`@\x81\x84\x03\x12a\x05hWa\x05@\x83_\x83\x01a\x04\xD1V[\x92` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x05cWa\x05_\x92\x01a\x04\xE8V[\x90\x91V[a\x02\xDDV[a\x01<V[4a\x05\x9EWa\x05\x9Aa\x05\x89a\x05\x836`\x04a\x05'V[\x91a\x1F\xAFV[a\x05\x91a\x012V[\x91\x82\x91\x82a\x01iV[\x03\x90\xF3[a\x018V[\x90` \x82\x82\x03\x12a\x05\xBCWa\x05\xB9\x91_\x01a\x04\xD1V[\x90V[a\x01<V[\x90V[a\x05\xD8a\x05\xD3a\x05\xDD\x92a\x01OV[a\x05\xC1V[a\x01OV[\x90V[\x90a\x05\xEA\x90a\x05\xC4V[_R` R`@_ \x90V[_\x1C\x90V[a\x06\x07a\x06\x0C\x91a\x05\xF6V[a\x01\xB7V[\x90V[a\x06\x19\x90Ta\x05\xFBV[\x90V[`@\x1C\x90V[a\x06.a\x063\x91a\x06\x1CV[a\x01\xB7V[\x90V[a\x06@\x90Ta\x06\"V[\x90V[\x90V[a\x06Ra\x06W\x91a\x05\xF6V[a\x06CV[\x90V[a\x06d\x90Ta\x06FV[\x90V[a\x06r\x90`\x01a\x05\xE0V[a\x06}_\x82\x01a\x06\x0FV[\x91a\x06\x95`\x01a\x06\x8E_\x85\x01a\x066V[\x93\x01a\x06ZV[\x90V[\x90V[a\x06\xA4\x90a\x06\x98V[\x90RV[`@\x90a\x06\xD1a\x06\xD8\x94\x96\x95\x93\x96a\x06\xC7``\x84\x01\x98_\x85\x01\x90a\x01\\V[` \x83\x01\x90a\x01\\V[\x01\x90a\x06\x9BV[V[4a\x07\rWa\x07\ta\x06\xF5a\x06\xF06`\x04a\x05\xA3V[a\x06gV[a\x07\0\x93\x91\x93a\x012V[\x93\x84\x93\x84a\x06\xA8V[\x03\x90\xF3[a\x018V[4a\x07@Wa\x07\"6`\x04a\x01@V[a\x07*a \x12V[a\x072a\x012V[\x80a\x07<\x81a\x044V[\x03\x90\xF3[a\x018V[a\x07N\x90a\x01OV[\x90RV[a\x07[\x90a\x06\x98V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x07\xA9a\x07\xB2` \x93a\x07\xB7\x93a\x07\xA0\x81a\x07rV[\x93\x84\x80\x93a\x07vV[\x95\x86\x91\x01a\x07\x7FV[a\x03\x0CV[\x01\x90V[Q\x90V[` \x91\x81R\x01\x90V[a\x07\xE7a\x07\xF0` \x93a\x07\xF5\x93a\x07\xDE\x81a\x07\xBBV[\x93\x84\x80\x93a\x07\xBFV[\x95\x86\x91\x01a\x07\x7FV[a\x03\x0CV[\x01\x90V[a\x08Q\x91``a\x08@a\x08.a\x08\x1C`\x80\x85\x01_\x87\x01Q\x86\x82\x03_\x88\x01Ra\x07\x8AV[` \x86\x01Q\x85\x82\x03` \x87\x01Ra\x07\x8AV[`@\x85\x01Q\x84\x82\x03`@\x86\x01Ra\x07\x8AV[\x92\x01Q\x90``\x81\x84\x03\x91\x01Ra\x07\xC8V[\x90V[\x90a\x08^\x91a\x07\xF9V[\x90V[` \x01\x90V[\x90a\x08{a\x08t\x83a\x07_V[\x80\x92a\x07cV[\x90\x81a\x08\x8C` \x83\x02\x84\x01\x94a\x07lV[\x92_\x91[\x83\x83\x10a\x08\x9FWPPPPP\x90V[\x90\x91\x92\x93\x94` a\x08\xC1a\x08\xBB\x83\x85`\x01\x95\x03\x87R\x89Qa\x08TV[\x97a\x08aV[\x93\x01\x93\x01\x91\x93\x92\x90a\x08\x90V[a\t\x1D\x91```\x80\x82\x01\x92a\x08\xE9_\x82\x01Q_\x85\x01\x90a\x07EV[a\x08\xFB` \x82\x01Q` \x85\x01\x90a\x07EV[a\t\r`@\x82\x01Q`@\x85\x01\x90a\x07RV[\x01Q\x90``\x81\x84\x03\x91\x01Ra\x08gV[\x90V[a\t5\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x08\xCEV[\x90V[4a\thWa\tda\tSa\tN6`\x04a\x05\xA3V[a\"\x9CV[a\t[a\x012V[\x91\x82\x91\x82a\t V[\x03\x90\xF3[a\x018V[4a\t\x9DWa\t}6`\x04a\x01@V[a\t\x99a\t\x88a#WV[a\t\x90a\x012V[\x91\x82\x91\x82a\x02\x93V[\x03\x90\xF3[a\x018V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\t\xC0Wa\t\xBC` \x91a\x03\x0CV[\x01\x90V[a\x03\x16V[\x90a\t\xD7a\t\xD2\x83a\t\xA2V[a\x03SV[\x91\x82RV[_\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\n\r`\x05a\t\xC5V[\x90a\n\x1A` \x83\x01a\t\xDCV[V[a\n$a\n\x03V[\x90V[a\n/a\n\x1CV[\x90V[a\n:a\n'V[\x90V[` \x91\x81R\x01\x90V[a\nea\nn` \x93a\ns\x93a\n\\\x81a\x07\xBBV[\x93\x84\x80\x93a\n=V[\x95\x86\x91\x01a\x07\x7FV[a\x03\x0CV[\x01\x90V[a\n\x8C\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\nFV[\x90V[4a\n\xBFWa\n\x9F6`\x04a\x01@V[a\n\xBBa\n\xAAa\n2V[a\n\xB2a\x012V[\x91\x82\x91\x82a\nwV[\x03\x90\xF3[a\x018V[\x90` \x82\x82\x03\x12a\n\xDDWa\n\xDA\x91_\x01a\x02\xF5V[\x90V[a\x01<V[4a\x0B\x10Wa\n\xFAa\n\xF56`\x04a\n\xC4V[a&EV[a\x0B\x02a\x012V[\x80a\x0B\x0C\x81a\x044V[\x03\x90\xF3[a\x018V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x0B\\W[` \x83\x10\x14a\x0BWWV[a\x0B(V[\x91`\x7F\x16\x91a\x0BLV[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0B\x89a\x0B\x82\x83a\x0B<V[\x80\x94a\x07vV[\x91`\x01\x81\x16\x90\x81_\x14a\x0B\xE0WP`\x01\x14a\x0B\xA4W[PPPV[a\x0B\xB1\x91\x92\x93\x94Pa\x0BfV[\x91_\x92[\x81\x84\x10a\x0B\xC8WPP\x01\x90_\x80\x80a\x0B\x9FV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0B\xB5V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0B\x9FV[\x90a\x0C\x05\x91a\x0BoV[\x90V[\x90a\x0C(a\x0C!\x92a\x0C\x18a\x012V[\x93\x84\x80\x92a\x0B\xFBV[\x03\x83a\x03*V[V[\x90_\x10a\x0C=Wa\x0C:\x90a\x0C\x08V[\x90V[a\x0B\x15V[a\x0CM__\x90a\x0C*V[\x90V[` \x91\x81R\x01\x90V[a\x0Cxa\x0C\x81` \x93a\x0C\x86\x93a\x0Co\x81a\x07rV[\x93\x84\x80\x93a\x0CPV[\x95\x86\x91\x01a\x07\x7FV[a\x03\x0CV[\x01\x90V[a\x0C\x9F\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x0CYV[\x90V[4a\x0C\xD2Wa\x0C\xB26`\x04a\x01@V[a\x0C\xCEa\x0C\xBDa\x0CBV[a\x0C\xC5a\x012V[\x91\x82\x91\x82a\x0C\x8AV[\x03\x90\xF3[a\x018V[4a\r\x05Wa\x0C\xEFa\x0C\xEA6`\x04a\n\xC4V[a'*V[a\x0C\xF7a\x012V[\x80a\r\x01\x81a\x044V[\x03\x90\xF3[a\x018V[4a\r8Wa\r\"a\r\x1D6`\x04a\x05\xA3V[a)\xEBV[a\r*a\x012V[\x80a\r4\x81a\x044V[\x03\x90\xF3[a\x018V[4a\rkWa\rUa\rP6`\x04a\n\xC4V[a*[V[a\r]a\x012V[\x80a\rg\x81a\x044V[\x03\x90\xF3[a\x018V[\x90\x91\x82`\x1F\x83\x01\x12\x15a\r\xAAW\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\r\xA5W` \x01\x92`\x01\x83\x02\x84\x01\x11a\r\xA0WV[a\x04\xE4V[a\x04\xE0V[a\x03\x04V[\x90` \x82\x82\x03\x12a\r\xE0W_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\r\xDBWa\r\xD7\x92\x01a\rpV[\x90\x91V[a\x02\xDDV[a\x01<V[4a\x0E\x14Wa\r\xFEa\r\xF86`\x04a\r\xAFV[\x90a,(V[a\x0E\x06a\x012V[\x80a\x0E\x10\x81a\x044V[\x03\x90\xF3[a\x018V[_\x80\xFD[_\x90V[a\x0E5a\x0E0a\x0E:\x92a\x06\x98V[a\x05\xC1V[a\x01OV[\x90V[`\xA0\x1C\x90V[a\x0EOa\x0ET\x91a\x0E=V[a\x01\xB7V[\x90V[a\x0Ea\x90Ta\x0ECV[\x90V[\x90V[a\x0E{a\x0Eva\x0E\x80\x92a\x0EdV[a\x05\xC1V[a\x01OV[\x90V[\x90V[a\x0E\x9Aa\x0E\x95a\x0E\x9F\x92a\x0E\x83V[a\x05\xC1V[a\x01OV[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x0E\xC2a\x0E\xC8\x91a\x01OV[\x91a\x01OV[\x90\x03\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x0E\xDCWV[a\x0E\xA2V[a\x0E\xEA\x90a\x01OV[_\x81\x14a\x0E\xF8W`\x01\x90\x03\x90V[a\x0E\xA2V[a\x0F\x05a\x0E\x1DV[Pa\x0F\x0FBa\x0E!V[\x90a\x0F\x1A`\x02a\x0EWV[a\x0F,a\x0F&_a\x0EgV[\x91a\x01OV[\x14\x80\x15a\x10\x15W[a\x0F\xF9Wa\x0FUa\x0FE`\x02a\x0EWV[a\x0FO`\x01a\x0E\x86V[\x90a\x0E\xB6V[[\x80a\x0Fra\x0Fla\x0Fg`\x03a\x06\x0FV[a\x01OV[\x91a\x01OV[\x10a\x0F\xF1W\x82a\x0F\x9Fa\x0F\x99a\x0F\x94_a\x0F\x8E`\x01\x87\x90a\x05\xE0V[\x01a\x066V[a\x01OV[\x91a\x01OV[\x10\x15a\x0F\xEBW\x80a\x0F\xB8a\x0F\xB2_a\x0EgV[\x91a\x01OV[\x14a\x0F\xCBWa\x0F\xC6\x90a\x0E\xE1V[a\x0FVV[PPP[_c#x\x8E\x81`\xE0\x1B\x81R\x80a\x0F\xE7`\x04\x82\x01a\x044V[\x03\x90\xFD[\x90\x91P\x90V[PPPa\x0F\xCFV[_c#x\x8E\x81`\xE0\x1B\x81R\x80a\x10\x11`\x04\x82\x01a\x044V[\x03\x90\xFD[Pa\x10 `\x03a\x06\x0FV[a\x10;a\x105a\x100`\x02a\x0EWV[a\x01OV[\x91a\x01OV[\x10\x15a\x0F4V[\x90a\x10T\x91a\x10Oa,@V[a\x10VV[V[\x90a\x10i\x91a\x10d\x81a,\xF2V[a-hV[V[\x90a\x10u\x91a\x10BV[V[_\x90V[a\x10\x8C\x90a\x10\x87a.fV[a\x10\xDFV[\x90V[\x90V[_\x1B\x90V[a\x10\xABa\x10\xA6a\x10\xB0\x92a\x10\x8FV[a\x10\x92V[a\x04cV[\x90V[a\x10\xDC\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x10\x97V[\x90V[Pa\x10\xE8a\x10\xB3V[\x90V[a\x10\xFBa\x10\xF6a\x10wV[a\x10{V[\x90V[\x90a\x11\x12\x93\x92\x91a\x11\ra.\xC4V[a\x1D\x8EV[\x90V[P\x90V[a\x11-a\x11(a\x112\x92a\x0EdV[a\x05\xC1V[a\x06\x98V[\x90V[\x91` a\x11V\x92\x94\x93a\x11O`@\x82\x01\x96_\x83\x01\x90a\x01\\V[\x01\x90a\x01\\V[V[a\x11b`\x80a\x03SV[\x90V[\x90a\x11o\x90a\x01OV[\x90RV[\x90a\x11}\x90a\x06\x98V[\x90RV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x11\x99W` \x80\x91\x02\x01\x90V[a\x03\x16V[_\x80\xFD[_\x80\xFD[\x90\x92\x91\x92a\x11\xBBa\x11\xB6\x82a\t\xA2V[a\x03SV[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x11\xD7Wa\x11\xD5\x92a\x03\x8BV[V[a\x03\x08V[\x90\x80`\x1F\x83\x01\x12\x15a\x11\xFAW\x81` a\x11\xF7\x935\x91\x01a\x11\xA6V[\x90V[a\x03\x04V[\x91\x90\x91`\x80\x81\x84\x03\x12a\x12\xBDWa\x12\x16`\x80a\x03SV[\x92_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x12\xB8W\x81a\x126\x91\x84\x01a\x03\xCCV[_\x85\x01R` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x12\xB3W\x81a\x12Z\x91\x84\x01a\x03\xCCV[` \x85\x01R`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x12\xAEW\x81a\x12\x7F\x91\x84\x01a\x03\xCCV[`@\x85\x01R``\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x12\xA9Wa\x12\xA2\x92\x01a\x11\xDCV[``\x83\x01RV[a\x11\xA2V[a\x11\xA2V[a\x11\xA2V[a\x11\xA2V[a\x11\x9EV[\x92\x91\x90a\x12\xD6a\x12\xD1\x82a\x11\x81V[a\x03SV[\x93\x81\x85R` \x80\x86\x01\x92\x02\x81\x01\x91\x83\x83\x11a\x13-W\x81\x90[\x83\x82\x10a\x12\xFCWPPPPPV[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x13(W` \x91a\x13\x1D\x87\x84\x93\x87\x01a\x11\xFFV[\x81R\x01\x91\x01\x90a\x12\xEEV[a\x03\x04V[a\x04\xE4V[a\x13=\x916\x91a\x12\xC2V[\x90V[RV[a\x13M\x90Qa\x01OV[\x90V[\x90a\x13cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x10\x92V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a\x13\x85a\x13\x80a\x13\x8C\x92a\x05\xC4V[a\x13mV[\x82Ta\x13PV[\x90UV[`@\x1B\x90V[\x90a\x13\xB1o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x91a\x13\x90V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x13\xD0a\x13\xCBa\x13\xD7\x92a\x05\xC4V[a\x13mV[\x82Ta\x13\x96V[\x90UV[a\x13\xE5\x90Qa\x06\x98V[\x90V[\x90a\x13\xF4_\x19\x91a\x10\x92V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x14\x12a\x14\ra\x14\x17\x92a\x06\x98V[a\x05\xC1V[a\x06\x98V[\x90V[\x90V[\x90a\x142a\x14-a\x149\x92a\x13\xFEV[a\x14\x1AV[\x82Ta\x13\xE8V[\x90UV[Q\x90V[T\x90V[a\x14Ta\x14Z\x91\x93\x92\x93a\x06\x98V[\x92a\x06\x98V[\x91a\x14f\x83\x82\x02a\x06\x98V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x14uWV[a\x0E\xA2V[a\x14\x85\x90`\x04a\x14EV[\x90V[_R` _ \x90V[\x90a\x14\xA4\x90_\x19\x90` \x03`\x08\x02a\x01\xB3V[\x81T\x16\x90UV[\x1B\x90V[\x91\x90`\x08a\x14\xCA\x91\x02\x91a\x14\xC4_\x19\x84a\x14\xABV[\x92a\x14\xABV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x14\xEAa\x14\xE5a\x14\xF2\x93a\x13\xFEV[a\x14\x1AV[\x90\x83Ta\x14\xAFV[\x90UV[_\x90V[a\x15\x0C\x91a\x15\x06a\x14\xF6V[\x91a\x14\xD4V[V[[\x81\x81\x10a\x15\x1AWPPV[\x80a\x15'_`\x01\x93a\x14\xFAV[\x01a\x15\x0FV[\x90a\x15=\x90_\x19\x90`\x08\x02a\x01\xB3V[\x19\x16\x90V[\x81a\x15L\x91a\x15-V[\x90`\x02\x02\x17\x90V[\x90_\x91a\x15ka\x15c\x82a\x0BfV[\x92\x83Ta\x15BV[\x90UUV[`\x1F` \x91\x01\x04\x90V[\x91\x92\x90` \x82\x10_\x14a\x15\xD3W`\x1F\x84\x11`\x01\x14a\x15\xA3Wa\x15\x9D\x92\x93Pa\x15BV[\x90U[[V[P\x90a\x15\xC9a\x15\xCE\x93`\x01a\x15\xC0a\x15\xBA\x85a\x0BfV[\x92a\x15pV[\x82\x01\x91\x01a\x15\x0EV[a\x15TV[a\x15\xA0V[Pa\x16\n\x82\x93a\x15\xE4`\x01\x94a\x0BfV[a\x16\x03a\x15\xF0\x85a\x15pV[\x82\x01\x92`\x1F\x86\x16\x80a\x16\x15W[Pa\x15pV[\x01\x90a\x15\x0EV[`\x02\x02\x17\x90Ua\x15\xA1V[a\x16!\x90\x88\x86\x03a\x14\x91V[_a\x15\xFDV[\x92\x90\x91h\x01\0\0\0\0\0\0\0\0\x82\x11a\x16\x87W` \x11_\x14a\x16xW` \x81\x10_\x14a\x16\\Wa\x16V\x91a\x15BV[\x90U[[V[`\x01\x91`\xFF\x19\x16a\x16l\x84a\x0BfV[U`\x02\x02\x01\x90Ua\x16YV[`\x01\x91P`\x02\x02\x01\x90Ua\x16ZV[a\x03\x16V[\x90\x81Ta\x16\x98\x81a\x0B<V[\x90\x81\x83\x11a\x16\xC1W[\x81\x83\x10a\x16\xAFW[PPPPV[a\x16\xB8\x93a\x15zV[_\x80\x80\x80a\x16\xA9V[a\x16\xCD\x83\x83\x83\x87a\x16'V[a\x16\xA1V[_a\x16\xDC\x91a\x16\x8CV[V[\x90_\x03a\x16\xF0Wa\x16\xEE\x90a\x16\xD2V[V[a\x0B\x15V[_R` _ \x90V[\x90_\x91a\x17\x15a\x17\r\x82a\x16\xF5V[\x92\x83Ta\x15BV[\x90UUV[\x91\x92\x90` \x82\x10_\x14a\x17sW`\x1F\x84\x11`\x01\x14a\x17CWa\x17=\x92\x93Pa\x15BV[\x90U[[V[P\x90a\x17ia\x17n\x93`\x01a\x17`a\x17Z\x85a\x16\xF5V[\x92a\x15pV[\x82\x01\x91\x01a\x15\x0EV[a\x16\xFEV[a\x17@V[Pa\x17\xAA\x82\x93a\x17\x84`\x01\x94a\x16\xF5V[a\x17\xA3a\x17\x90\x85a\x15pV[\x82\x01\x92`\x1F\x86\x16\x80a\x17\xB5W[Pa\x15pV[\x01\x90a\x15\x0EV[`\x02\x02\x17\x90Ua\x17AV[a\x17\xC1\x90\x88\x86\x03a\x14\x91V[_a\x17\x9DV[\x92\x90\x91h\x01\0\0\0\0\0\0\0\0\x82\x11a\x18'W` \x11_\x14a\x18\x18W` \x81\x10_\x14a\x17\xFCWa\x17\xF6\x91a\x15BV[\x90U[[V[`\x01\x91`\xFF\x19\x16a\x18\x0C\x84a\x16\xF5V[U`\x02\x02\x01\x90Ua\x17\xF9V[`\x01\x91P`\x02\x02\x01\x90Ua\x17\xFAV[a\x03\x16V[\x90\x81Ta\x188\x81a\x0B<V[\x90\x81\x83\x11a\x18aW[\x81\x83\x10a\x18OW[PPPPV[a\x18X\x93a\x17\x1AV[_\x80\x80\x80a\x18IV[a\x18m\x83\x83\x83\x87a\x17\xC7V[a\x18AV[_a\x18|\x91a\x18,V[V[\x90_\x03a\x18\x90Wa\x18\x8E\x90a\x18rV[V[a\x0B\x15V[_`\x03a\x18\xC8\x92a\x18\xA8\x83\x80\x83\x01a\x16\xDEV[a\x18\xB5\x83`\x01\x83\x01a\x16\xDEV[a\x18\xC2\x83`\x02\x83\x01a\x16\xDEV[\x01a\x18~V[V[\x90_\x03a\x18\xDCWa\x18\xDA\x90a\x18\x95V[V[a\x0B\x15V[[\x81\x81\x10a\x18\xEDWPPV[\x80a\x18\xFA_`\x04\x93a\x18\xCAV[\x01a\x18\xE2V[\x90\x91\x82\x81\x10a\x19\x0FW[PPPV[a\x19-a\x19'a\x19!a\x198\x95a\x14zV[\x92a\x14zV[\x92a\x14\x88V[\x91\x82\x01\x91\x01\x90a\x18\xE1V[_\x80\x80a\x19\nV[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x19iW\x81a\x19^a\x19g\x93a\x14AV[\x90\x82\x81Ua\x19\0V[V[a\x03\x16V[Q\x90V[Q\x90V[\x91\x90`\x1F\x81\x11a\x19\x86W[PPPV[a\x19\x92a\x19\xB7\x93a\x0BfV[\x90` a\x19\x9E\x84a\x15pV[\x83\x01\x93\x10a\x19\xBFW[a\x19\xB0\x90a\x15pV[\x01\x90a\x15\x0EV[_\x80\x80a\x19\x81V[\x91Pa\x19\xB0\x81\x92\x90Pa\x19\xA7V[\x90a\x19\xD7\x81a\x07rV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1A\x97Wa\x19\xFB\x82a\x19\xF5\x85Ta\x0B<V[\x85a\x19vV[` \x90`\x1F\x83\x11`\x01\x14a\x1A/W\x91\x80\x91a\x1A\x1E\x93_\x92a\x1A#W[PPa\x15BV[\x90U[V[\x90\x91P\x01Q_\x80a\x1A\x17V[`\x1F\x19\x83\x16\x91a\x1A>\x85a\x0BfV[\x92_[\x81\x81\x10a\x1A\x7FWP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x1AeW[PPP\x02\x01\x90Ua\x1A!V[a\x1Au\x91\x01Q`\x1F\x84\x16\x90a\x15-V[\x90U_\x80\x80a\x1AYV[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x1AAV[a\x03\x16V[\x90a\x1A\xA6\x91a\x19\xCDV[V[Q\x90V[\x91\x90`\x1F\x81\x11a\x1A\xBCW[PPPV[a\x1A\xC8a\x1A\xED\x93a\x16\xF5V[\x90` a\x1A\xD4\x84a\x15pV[\x83\x01\x93\x10a\x1A\xF5W[a\x1A\xE6\x90a\x15pV[\x01\x90a\x15\x0EV[_\x80\x80a\x1A\xB7V[\x91Pa\x1A\xE6\x81\x92\x90Pa\x1A\xDDV[\x90a\x1B\r\x81a\x07\xBBV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1B\xCDWa\x1B1\x82a\x1B+\x85Ta\x0B<V[\x85a\x1A\xACV[` \x90`\x1F\x83\x11`\x01\x14a\x1BeW\x91\x80\x91a\x1BT\x93_\x92a\x1BYW[PPa\x15BV[\x90U[V[\x90\x91P\x01Q_\x80a\x1BMV[`\x1F\x19\x83\x16\x91a\x1Bt\x85a\x16\xF5V[\x92_[\x81\x81\x10a\x1B\xB5WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x1B\x9BW[PPP\x02\x01\x90Ua\x1BWV[a\x1B\xAB\x91\x01Q`\x1F\x84\x16\x90a\x15-V[\x90U_\x80\x80a\x1B\x8FV[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x1BwV[a\x03\x16V[\x90a\x1B\xDC\x91a\x1B\x03V[V[\x90a\x1C;```\x03a\x1CA\x94a\x1C\x01_\x82\x01a\x1B\xFB_\x88\x01a\x19rV[\x90a\x1A\x9CV[a\x1C\x1A`\x01\x82\x01a\x1C\x14` \x88\x01a\x19rV[\x90a\x1A\x9CV[a\x1C3`\x02\x82\x01a\x1C-`@\x88\x01a\x19rV[\x90a\x1A\x9CV[\x01\x92\x01a\x1A\xA8V[\x90a\x1B\xD2V[V[\x90a\x1CM\x91a\x1B\xDEV[V[a\x1Cta\x1Cna\x1C^\x84a\x07_V[\x93a\x1Ci\x85\x85a\x19@V[a\x07lV[\x91a\x14\x88V[_\x91[\x83\x83\x10a\x1C\x84WPPPPV[`\x04` \x82a\x1C\x9Da\x1C\x97`\x01\x95a\x19nV[\x86a\x1CCV[\x01\x92\x01\x92\x01\x91\x90a\x1CwV[\x90a\x1C\xB3\x91a\x1COV[V[\x90a\x1D\x11```\x02a\x1D\x17\x94a\x1C\xD8_\x82\x01a\x1C\xD2_\x88\x01a\x13CV[\x90a\x13pV[a\x1C\xF0_\x82\x01a\x1C\xEA` \x88\x01a\x13CV[\x90a\x13\xBBV[a\x1D\t`\x01\x82\x01a\x1D\x03`@\x88\x01a\x13\xDBV[\x90a\x14\x1DV[\x01\x92\x01a\x14=V[\x90a\x1C\xA9V[V[\x90a\x1D#\x91a\x1C\xB5V[V[a\x1D.\x90a\x01OV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x14a\x1DCW`\x01\x01\x90V[a\x0E\xA2V[`\xA0\x1B\x90V[\x90a\x1Ddg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x91a\x1DHV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x1D\x83a\x1D~a\x1D\x8A\x92a\x05\xC4V[a\x13mV[\x82Ta\x1DNV[\x90UV[\x91\x90\x91Pa\x1D\x9D\x81\x84\x90a\x11\x15V[a\x1D\xAFa\x1D\xA9_a\x11\x19V[\x91a\x06\x98V[\x14a\x1F\x93Wa\x1D\xBE`\x02a\x0EWV[a\x1D\xD0a\x1D\xCA_a\x0EgV[\x91a\x01OV[\x11a\x1F#W[a\x1D\xE0`\x02a\x0EWV[a\x1D\xFAa\x1D\xF4g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x01OV[\x91a\x01OV[\x14a\x1F\x07Wa\x1EKa\x1ET\x91a\x1En\x94a\x1EFa\x1E\x17`\x02a\x0EWV[\x95\x92a\x1E=C\x91\x93\x94a\x1E4a\x1E+a\x11XV[\x99_\x8B\x01a\x11eV[` \x89\x01a\x11eV[`@\x87\x01a\x11sV[a\x132V[``\x83\x01a\x13@V[a\x1Ei`\x01a\x1Ec`\x02a\x0EWV[\x90a\x05\xE0V[a\x1D\x19V[a\x1E\x8Aa\x1E\x83a\x1E~`\x02a\x0EWV[a\x1D%V[`\x02a\x1DnV[a\x1E\xA7a\x1E\x97`\x02a\x0EWV[a\x1E\xA1`\x01a\x0E\x86V[\x90a\x0E\xB6V[a\x1E\xD1\x7F\x15\n\xEAkX\xAB\xE4=\xC5\xA1\x9BLs\x8Eh&\x11\xCB\x0F\x82e\xB8\x9Fm?\xF6N\x10\r\x84w\x7F\x91a\x05\xC4V[\x90a\x1E\xDAa\x012V[\x80a\x1E\xE4\x81a\x044V[\x03\x90\xA2a\x1F\x04a\x1E\xF4`\x02a\x0EWV[a\x1E\xFE`\x01a\x0E\x86V[\x90a\x0E\xB6V[\x90V[_c\x01\x15\xB1\x11`\xE7\x1B\x81R\x80a\x1F\x1F`\x04\x82\x01a\x044V[\x03\x90\xFD[a\x1FU_a\x1FO`\x01a\x1FIa\x1F9`\x02a\x0EWV[a\x1FC`\x01a\x0E\x86V[\x90a\x0E\xB6V[\x90a\x05\xE0V[\x01a\x066V[\x82a\x1Fha\x1Fb\x83a\x01OV[\x91a\x01OV[\x11\x15a\x1FtWPa\x1D\xD6V[\x82a\x1F\x8F_\x92\x83\x92c\xEA\xF69\xE5`\xE0\x1B\x84R`\x04\x84\x01a\x115V[\x03\x90\xFD[_c(6\x01\xE9`\xE2\x1B\x81R\x80a\x1F\xAB`\x04\x82\x01a\x044V[\x03\x90\xFD[\x90a\x1F\xC2\x92\x91a\x1F\xBDa\x0E\x1DV[a\x10\xFEV[\x90V[a\x1F\xCDa/\x06V[a\x1F\xD5a\x1F\xFFV[V[a\x1F\xEBa\x1F\xE6a\x1F\xF0\x92a\x0EdV[a\x05\xC1V[a\x02oV[\x90V[a\x1F\xFC\x90a\x1F\xD7V[\x90V[a \x10a \x0B_a\x1F\xF3V[a/TV[V[a \x1Aa\x1F\xC5V[V[a &`\x80a\x03SV[\x90V[_\x90V[_\x90V[``\x90V[a >a \x1CV[\x90` \x80\x80\x80\x85a Ma )V[\x81R\x01a Xa )V[\x81R\x01a ca -V[\x81R\x01a na 1V[\x81RPPV[a |a 6V[\x90V[\x90a \x91a \x8C\x83a\x11\x81V[a\x03SV[\x91\x82RV[RV[\x90_\x92\x91\x80T\x90a \xB3a \xAC\x83a\x0B<V[\x80\x94a\x07\xBFV[\x91`\x01\x81\x16\x90\x81_\x14a!\nWP`\x01\x14a \xCEW[PPPV[a \xDB\x91\x92\x93\x94Pa\x16\xF5V[\x91_\x92[\x81\x84\x10a \xF2WPP\x01\x90_\x80\x80a \xC9V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a \xDFV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a \xC9V[\x90a!/\x91a \x99V[\x90V[\x90a!Ra!K\x92a!Ba\x012V[\x93\x84\x80\x92a!%V[\x03\x83a\x03*V[V[RV[a!a`\x80a\x03SV[\x90V[\x90a!\xCBa!\xC2`\x03a!ua!WV[\x94a!\x8Ca!\x84_\x83\x01a\x0C\x08V[_\x88\x01a \x96V[a!\xA4a!\x9B`\x01\x83\x01a\x0C\x08V[` \x88\x01a \x96V[a!\xBCa!\xB3`\x02\x83\x01a\x0C\x08V[`@\x88\x01a \x96V[\x01a!2V[``\x84\x01a!TV[V[a!\xD6\x90a!dV[\x90V[\x90a!\xE3\x82a\x14AV[a!\xEC\x81a \x7FV[\x92a!\xFA` \x85\x01\x91a\x14\x88V[_\x91[\x83\x83\x10a\"\nWPPPPV[`\x04` `\x01\x92a\"\x1A\x85a!\xCDV[\x81R\x01\x92\x01\x92\x01\x91\x90a!\xFDV[\x90a\"\x8Ea\"\x85`\x02a\"9a \x1CV[\x94a\"Pa\"H_\x83\x01a\x06\x0FV[_\x88\x01a\x11eV[a\"ga\"^_\x83\x01a\x066V[` \x88\x01a\x11eV[a\"\x7Fa\"v`\x01\x83\x01a\x06ZV[`@\x88\x01a\x11sV[\x01a!\xD9V[``\x84\x01a\x13@V[V[a\"\x99\x90a\"(V[\x90V[a\"\xA4a tV[P\x80a\"\xC1a\"\xBBa\"\xB6`\x03a\x06\x0FV[a\x01OV[\x91a\x01OV[\x10\x80\x15a#\x02W[a\"\xE3Wa\"\xDBa\"\xE0\x91`\x01a\x05\xE0V[a\"\x90V[\x90V[a\"\xFE\x90_\x91\x82\x91cxD\x813`\xE0\x1B\x83R`\x04\x83\x01a\x01iV[\x03\x90\xFD[Pa#\x19_a#\x13`\x01\x84\x90a\x05\xE0V[\x01a\x06\x0FV[a#+a#%\x83a\x01OV[\x91a\x01OV[\x14\x15a\"\xC9V[_\x90V[a#Ba#G\x91a\x05\xF6V[a\x02/V[\x90V[a#T\x90Ta#6V[\x90V[a#_a#2V[Pa#r_a#la/\xC0V[\x01a#JV[\x90V[`\xFF\x16\x90V[a#\x87a#\x8C\x91a\x06\x1CV[a#uV[\x90V[a#\x99\x90Ta#{V[\x90V[\x15\x15\x90V[a#\xB5a#\xB0a#\xBA\x92a\x02oV[a\x05\xC1V[a\x02oV[\x90V[a#\xC6\x90a#\xA1V[\x90V[a#\xD2\x90a#\xBDV[\x90V[\x90a#\xE9h\xFF\0\0\0\0\0\0\0\0\x91a\x13\x90V[\x91\x81\x19\x16\x91\x16\x17\x90V[a#\xFC\x90a#\x9CV[\x90V[\x90V[\x90a$\x17a$\x12a$\x1E\x92a#\xF3V[a#\xFFV[\x82Ta#\xD5V[\x90UV[a$+\x90a\x0E\x86V[\x90RV[\x91\x90a$B\x90_` \x85\x01\x94\x01\x90a$\"V[V[a$La/\xE4V[\x90a$aa$[_\x84\x01a#\x8FV[\x15a#\x9CV[\x90a$m_\x84\x01a\x06\x0FV[\x80a$\x80a$z_a\x0EgV[\x91a\x01OV[\x14\x80a%\x9AW[\x90a$\x9Ba$\x95`\x01a\x0E\x86V[\x91a\x01OV[\x14\x80a%rW[a$\xAD\x90\x91\x15a#\x9CV[\x90\x81a%aW[Pa%EWa$\xDD\x90a$\xD2a$\xCA`\x01a\x0E\x86V[_\x86\x01a\x13pV[\x82a%3W[a%\xEBV[a$\xE5W[PV[a$\xF2\x90_\x80\x91\x01a$\x02V[`\x01a%*\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x91a%!a\x012V[\x91\x82\x91\x82a$/V[\x03\x90\xA1_a$\xE2V[a%@`\x01_\x86\x01a$\x02V[a$\xD8V[_c\xF9.\xE8\xA9`\xE0\x1B\x81R\x80a%]`\x04\x82\x01a\x044V[\x03\x90\xFD[a%l\x91P\x15a#\x9CV[_a$\xB4V[Pa$\xADa%\x7F0a#\xC9V[;a%\x92a%\x8C_a\x11\x19V[\x91a\x06\x98V[\x14\x90Pa$\xA2V[P\x82a$\x87V[\x90a%\xB2`\x01\x80`\xA0\x1B\x03\x91a\x10\x92V[\x91\x81\x19\x16\x91\x16\x17\x90V[a%\xC5\x90a#\xBDV[\x90V[\x90V[\x90a%\xE0a%\xDBa%\xE7\x92a%\xBCV[a%\xC8V[\x82Ta%\xA1V[\x90UV[\x80a&\x06a&\0a%\xFB_a\x1F\xF3V[a\x02zV[\x91a\x02zV[\x14a&)Wa&'\x90a&\x183a0\rV[a& a0\"V[`\x02a%\xCBV[V[_c\xE6\xC4${`\xE0\x1B\x81R\x80a&A`\x04\x82\x01a\x044V[\x03\x90\xFD[a&N\x90a$DV[V[a&a\x90a&\\a/\x06V[a&cV[V[\x80a&~a&xa&s_a\x1F\xF3V[a\x02zV[\x91a\x02zV[\x14\x80\x15a'\x07W[a&\xEBWa&\x94`\x02a#JV[a&\x9F\x82`\x02a%\xCBV[\x90a&\xD3a&\xCD\x7F`\\-\xBFv._}`\xA5F\xD4.r\x05\xDC\xB1\xB0\x11\xEB\xC6*asjW\xC9\x08\x9D:CP\x93a%\xBCV[\x91a%\xBCV[\x91a&\xDCa\x012V[\x80a&\xE6\x81a\x044V[\x03\x90\xA3V[_c\xE6\xC4${`\xE0\x1B\x81R\x80a'\x03`\x04\x82\x01a\x044V[\x03\x90\xFD[P\x80a'$a'\x1Ea'\x19`\x02a#JV[a\x02zV[\x91a\x02zV[\x14a&\x86V[a'3\x90a&PV[V[a'F\x90a'Aa.\xC4V[a(CV[V[`@\x90a'qa'x\x94\x96\x95\x93\x96a'g``\x84\x01\x98_\x85\x01\x90a\x01\\V[` \x83\x01\x90a\x01\\V[\x01\x90a\x01\\V[V[\x90V[a'\x91a'\x8Ca'\x96\x92a'zV[a\x05\xC1V[a\x06\x98V[\x90V[a'\xA8a'\xAE\x91\x93\x92\x93a\x06\x98V[\x92a\x06\x98V[\x82\x03\x91\x82\x11a'\xB9WV[a\x0E\xA2V[_a'\xC8\x91a\x19@V[V[\x90_\x03a'\xDCWa'\xDA\x90a'\xBEV[V[a\x0B\x15V[_`\x02a(\0\x92\x82\x80\x82\x01Ua'\xFA\x83`\x01\x83\x01a\x14\xFAV[\x01a'\xCAV[V[\x90_\x03a(\x14Wa(\x12\x90a'\xE1V[V[a\x0B\x15V[a(%a(+\x91a\x01OV[\x91a\x01OV[\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a(>WV[a\x0E\xA2V[\x90\x81a(`a(Za(U`\x03a\x06\x0FV[a\x01OV[\x91a\x01OV[\x10\x80\x15a)\xC7W[a)\x93Wa(\x89a(\x84Ba(~a\x02Xa'}V[\x90a'\x99V[a\x0E!V[\x90a(\x94`\x03a\x06\x0FV[\x92a(\x9F`\x03a\x06\x0FV[[\x80a(\xB3a(\xAD\x84a\x01OV[\x91a\x01OV[\x11a)%Wa(\xCE_a(\xC8`\x01\x84\x90a\x05\xE0V[\x01a\x066V[a(\xE0a(\xDA\x86a\x01OV[\x91a\x01OV[\x10\x15a)\tWa)\x04\x90a(\xFF_a(\xFA`\x01\x84\x90a\x05\xE0V[a(\x02V[a\x1D%V[a(\xA0V[_cu\xB9B\xBB`\xE0\x1B\x81R\x80a)!`\x04\x82\x01a\x044V[\x03\x90\xFD[P\x91P\x91a)Ga)@\x83a):`\x01a\x0E\x86V[\x90a(\x19V[`\x03a\x13pV[\x90a){a)u\x7F\xE9\x05\x0BtB\xEBgN\xD5\xECz\xA7\xE2\x14U\xF8\xB74N@s\x85\xC1\xA8\x10\xE4\xAB\\*\x0E\xD8\xA2\x93a\x05\xC4V[\x91a\x05\xC4V[\x91a)\x84a\x012V[\x80a)\x8E\x81a\x044V[\x03\x90\xA3V[Pa)\x9E`\x03a\x06\x0FV[\x90a)\xC3a)\xAC`\x02a\x0EWV[_\x93\x84\x93c\x19\x0E\x9FK`\xE1\x1B\x85R`\x04\x85\x01a'HV[\x03\x90\xFD[P\x81a)\xE4a)\xDEa)\xD9`\x02a\x0EWV[a\x01OV[\x91a\x01OV[\x10\x15a(hV[a)\xF4\x90a'5V[V[a*\x07\x90a*\x02a/\x06V[a*\tV[V[\x80a*$a*\x1Ea*\x19_a\x1F\xF3V[a\x02zV[\x91a\x02zV[\x14a*4Wa*2\x90a/TV[V[a*Wa*@_a\x1F\xF3V[_\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[a*d\x90a)\xF6V[V[\x90a*x\x91a*sa.\xC4V[a+\xA4V[V[a*\x84\x90Ta\x0B<V[\x90V[P\x90V[\x91a*\x96\x90\x82a*\x87V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a+UWa*\xBA\x82a*\xB4\x85Ta\x0B<V[\x85a\x19vV[_\x90`\x1F\x83\x11`\x01\x14a*\xEDW\x91\x80\x91a*\xDC\x93_\x92a*\xE1W[PPa\x15BV[\x90U[V[\x90\x91P\x015_\x80a*\xD5V[`\x1F\x19\x83\x16\x91a*\xFC\x85a\x0BfV[\x92_[\x81\x81\x10a+=WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a+#W[PPP\x02\x01\x90Ua*\xDFV[a+3\x91\x015`\x1F\x84\x16\x90a\x15-V[\x90U_\x80\x80a+\x17V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a*\xFFV[a\x03\x16V[\x90a+e\x92\x91a*\x8BV[V[\x91\x90a+\x81\x81a+z\x81a+\x86\x95a\x0CPV[\x80\x95a\x03\x8BV[a\x03\x0CV[\x01\x90V[\x90\x91a+\xA1\x92` \x83\x01\x92_\x81\x85\x03\x91\x01Ra+gV[\x90V[a+\xAD_a*zV[a+\xBFa+\xB9_a\x11\x19V[\x91a\x06\x98V[\x11a,\x0CWa+\xD0\x81\x83\x90_a+ZV[\x90\x7FTH H\xE8=\xCA\x02\x801\x0B4\x1D\x9A\xCF#j\xC8\xB0\xAE\x10]\xC9b\x1D\xB5q_h:\"\xE7\x91a,\x07a+\xFEa\x012V[\x92\x83\x92\x83a+\x8AV[\x03\x90\xA1V[_c~\x8AC+`\xE0\x1B\x81R\x80a,$`\x04\x82\x01a\x044V[\x03\x90\xFD[\x90a,2\x91a*fV[V[a,=\x90a#\xBDV[\x90V[a,I0a,4V[a,{a,u\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x02zV[\x91a\x02zV[\x14\x80\x15a,\xA5W[a,\x89WV[_cp>F\xDD`\xE1\x1B\x81R\x80a,\xA1`\x04\x82\x01a\x044V[\x03\x90\xFD[Pa,\xAEa0,V[a,\xE0a,\xDA\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x02zV[\x91a\x02zV[\x14\x15a,\x83V[Pa,\xF0a/\x06V[V[a,\xFB\x90a,\xE7V[V[a-\x06\x90a#\xA1V[\x90V[a-\x12\x90a,\xFDV[\x90V[a-\x1E\x90a#\xBDV[\x90V[`\xE0\x1B\x90V[a-0\x81a\x04cV[\x03a-7WV[_\x80\xFD[\x90PQ\x90a-H\x82a-'V[V[\x90` \x82\x82\x03\x12a-cWa-`\x91_\x01a-;V[\x90V[a\x01<V[\x91\x90a-\x96` a-\x80a-{\x86a-\tV[a-\x15V[cR\xD1\x90-\x90a-\x8Ea\x012V[\x93\x84\x92a-!V[\x82R\x81\x80a-\xA6`\x04\x82\x01a\x044V[\x03\x91Z\xFA\x80\x91_\x92a.6W[P\x15_\x14a-\xE7WPP\x90`\x01a-\xC8WP[V[a-\xE3\x90_\x91\x82\x91cL\x9C\x8C\xE3`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[\x92\x83a.\x02a-\xFCa-\xF7a\x10\xB3V[a\x04cV[\x91a\x04cV[\x03a.\x17Wa.\x12\x92\x93Pa0RV[a-\xC6V[a.2\x84_\x91\x82\x91c*\x87Ri`\xE2\x1B\x83R`\x04\x83\x01a\x04sV[\x03\x90\xFD[a.X\x91\x92P` =\x81\x11a._W[a.P\x81\x83a\x03*V[\x81\x01\x90a-JV[\x90_a-\xB3V[P=a.FV[a.o0a,4V[a.\xA1a.\x9B\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x02zV[\x91a\x02zV[\x03a.\xA8WV[_cp>F\xDD`\xE1\x1B\x81R\x80a.\xC0`\x04\x82\x01a\x044V[\x03\x90\xFD[3a.\xE0a.\xDAa.\xD5`\x02a#JV[a\x02zV[\x91a\x02zV[\x03a.\xE7WV[a/\x023_\x91\x82\x91c*\x19\xE83`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[a/\x0Ea#WV[a/'a/!a/\x1Ca0\xDBV[a\x02zV[\x91a\x02zV[\x03a/.WV[a/Pa/9a0\xDBV[_\x91\x82\x91c\x11\x8C\xDA\xA7`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[a/\\a/\xC0V[a/ta/j_\x83\x01a#JV[\x91_\x84\x91\x01a%\xCBV[\x90a/\xA8a/\xA2\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x93a%\xBCV[\x91a%\xBCV[\x91a/\xB1a\x012V[\x80a/\xBB\x81a\x044V[\x03\x90\xA3V[\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90V[a/\xECa13V[\x90V[a0\0\x90a/\xFBa1GV[a0\x02V[V[a0\x0B\x90a1\xDFV[V[a0\x16\x90a/\xEFV[V[a0 a1GV[V[a0*a0\x18V[V[a04a#2V[Pa0O_a0Ia0Da\x10\xB3V[a1\xEAV[\x01a#JV[\x90V[\x90a0\\\x82a1\xEDV[\x81a0\x87\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x91a%\xBCV[\x90a0\x90a\x012V[\x80a0\x9A\x81a\x044V[\x03\x90\xA2a0\xA6\x81a\x07rV[a0\xB8a0\xB2_a\x11\x19V[\x91a\x06\x98V[\x11_\x14a0\xCCWa0\xC8\x91a2\xBDV[P[V[PPa0\xD6a2BV[a0\xCAV[a0\xE3a#2V[P3\x90V[\x90V[a0\xFFa0\xFAa1\x04\x92a0\xE8V[a\x10\x92V[a\x04cV[\x90V[a10\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0a0\xEBV[\x90V[a1;a\x10wV[Pa1Da1\x07V[\x90V[a1Xa1Ra2\xF0V[\x15a#\x9CV[a1^WV[_c\x1A\xFC\xD7\x9F`\xE3\x1B\x81R\x80a1v`\x04\x82\x01a\x044V[\x03\x90\xFD[a1\x8B\x90a1\x86a1GV[a1\x8DV[V[\x80a1\xA8a1\xA2a1\x9D_a\x1F\xF3V[a\x02zV[\x91a\x02zV[\x14a1\xB8Wa1\xB6\x90a/TV[V[a1\xDBa1\xC4_a\x1F\xF3V[_\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[a1\xE8\x90a1zV[V[\x90V[\x80;a2\x01a1\xFB_a\x11\x19V[\x91a\x06\x98V[\x14a2#Wa2!\x90_a2\x1Ba2\x16a\x10\xB3V[a1\xEAV[\x01a%\xCBV[V[a2>\x90_\x91\x82\x91cL\x9C\x8C\xE3`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[4a2Ua2O_a\x11\x19V[\x91a\x06\x98V[\x11a2\\WV[_c\xB3\x98\x97\x9F`\xE0\x1B\x81R\x80a2t`\x04\x82\x01a\x044V[\x03\x90\xFD[``\x90V[\x90a2\x8Fa2\x8A\x83a\x03hV[a\x03SV[\x91\x82RV[=_\x14a2\xAFWa2\xA4=a2}V[\x90=_` \x84\x01>[V[a2\xB7a2xV[\x90a2\xADV[_\x80a2\xE9\x93a2\xCBa2xV[P\x83\x90` \x81\x01\x90Q\x91Z\xF4\x90a2\xE0a2\x94V[\x90\x91\x90\x91a3\x0EV[\x90V[_\x90V[a2\xF8a2\xECV[Pa3\x0B_a3\x05a/\xE4V[\x01a#\x8FV[\x90V[\x90a3\"\x90a3\x1Ba2xV[P\x15a#\x9CV[_\x14a3.WPa3\x92V[a37\x82a\x07rV[a3Ia3C_a\x11\x19V[\x91a\x06\x98V[\x14\x80a3wW[a3XWP\x90V[a3s\x90_\x91\x82\x91c\x99\x96\xB3\x15`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[P\x80;a3\x8Ca3\x86_a\x11\x19V[\x91a\x06\x98V[\x14a3PV[a3\x9B\x81a\x07rV[a3\xADa3\xA7_a\x11\x19V[\x91a\x06\x98V[\x11_\x14a3\xBCW` \x81Q\x91\x01\xFD[_c\xD6\xBD\xA2u`\xE0\x1B\x81R\x80a3\xD4`\x04\x82\x01a\x044V[\x03\x90\xFD\xFE\xA2dipfsX\"\x12 x3\xE9:w\x99$T\xDA\xEB|\xC9\xBE\xC9\x04\x9BEha{`\xCE9j\x8Fy\xD9\x9C|\xF5\x91\xB7dsolcC\0\x08\x1E\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b610e19565b61001d5f3561012c565b80630f1569cb1461012757806328ce469214610122578063481c6a751461011d5780634f1ef2861461011857806352d1902d146101135780635b3d1f0a1461010e57806369f8bfa814610109578063715018a614610104578063824cd9f8146100ff5780638da5cb5b146100fa578063ad3cb1cc146100f5578063c4d66de8146100f0578063d00d5a5c146100eb578063d0ebdbe7146100e6578063e5b51606146100e1578063f2fde38b146100dc5763f84067660361000e57610de5565b610d3d565b610d0a565b610cd7565b610ca2565b610ae2565b610a8f565b61096d565b610938565b610712565b6106da565b61056d565b610488565b610439565b6102a8565b6101fa565b61017e565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261014a57565b61013c565b67ffffffffffffffff1690565b6101659061014f565b9052565b919061017c905f6020850194019061015c565b565b346101ae5761018e366004610140565b6101aa610199610efd565b6101a1610132565b91829182610169565b0390f35b610138565b1c90565b67ffffffffffffffff1690565b6101d49060086101d993026101b3565b6101b7565b90565b906101e791546101c4565b90565b6101f760026014906101dc565b90565b3461022a5761020a366004610140565b6102266102156101ea565b61021d610132565b91829182610169565b0390f35b610138565b60018060a01b031690565b61024a90600861024f93026101b3565b61022f565b90565b9061025d915461023a565b90565b61026c60025f90610252565b90565b60018060a01b031690565b6102839061026f565b90565b61028f9061027a565b9052565b91906102a6905f60208501940190610286565b565b346102d8576102b8366004610140565b6102d46102c3610260565b6102cb610132565b91829182610293565b0390f35b610138565b5f80fd5b6102ea8161027a565b036102f157565b5f80fd5b90503590610302826102e1565b565b5f80fd5b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906103349061030c565b810190811067ffffffffffffffff82111761034e57604052565b610316565b9061036661035f610132565b928361032a565b565b67ffffffffffffffff81116103865761038260209161030c565b0190565b610316565b90825f939282370152565b909291926103ab6103a682610368565b610353565b938185526020850190828401116103c7576103c59261038b565b565b610308565b9080601f830112156103ea578160206103e793359101610396565b90565b610304565b91909160408184031261042f57610408835f83016102f5565b92602082013567ffffffffffffffff811161042a5761042792016103cc565b90565b6102dd565b61013c565b5f0190565b61044d6104473660046103ef565b9061106b565b610455610132565b8061045f81610434565b0390f35b90565b61046f90610463565b9052565b9190610486905f60208501940190610466565b565b346104b857610498366004610140565b6104b46104a36110eb565b6104ab610132565b91829182610473565b0390f35b610138565b6104c68161014f565b036104cd57565b5f80fd5b905035906104de826104bd565b565b5f80fd5b5f80fd5b909182601f830112156105225781359167ffffffffffffffff831161051d57602001926020830284011161051857565b6104e4565b6104e0565b610304565b91909160408184031261056857610540835f83016104d1565b92602082013567ffffffffffffffff81116105635761055f92016104e8565b9091565b6102dd565b61013c565b3461059e5761059a610589610583366004610527565b91611faf565b610591610132565b91829182610169565b0390f35b610138565b906020828203126105bc576105b9915f016104d1565b90565b61013c565b90565b6105d86105d36105dd9261014f565b6105c1565b61014f565b90565b906105ea906105c4565b5f5260205260405f2090565b5f1c90565b61060761060c916105f6565b6101b7565b90565b61061990546105fb565b90565b60401c90565b61062e6106339161061c565b6101b7565b90565b6106409054610622565b90565b90565b610652610657916105f6565b610643565b90565b6106649054610646565b90565b6106729060016105e0565b61067d5f820161060f565b91610695600161068e5f8501610636565b930161065a565b90565b90565b6106a490610698565b9052565b6040906106d16106d894969593966106c760608401985f85019061015c565b602083019061015c565b019061069b565b565b3461070d576107096106f56106f03660046105a3565b610667565b610700939193610132565b938493846106a8565b0390f35b610138565b3461074057610722366004610140565b61072a612012565b610732610132565b8061073c81610434565b0390f35b610138565b61074e9061014f565b9052565b61075b90610698565b9052565b5190565b60209181520190565b60200190565b5190565b60209181520190565b90825f9392825e0152565b6107a96107b26020936107b7936107a081610772565b93848093610776565b9586910161077f565b61030c565b0190565b5190565b60209181520190565b6107e76107f06020936107f5936107de816107bb565b938480936107bf565b9586910161077f565b61030c565b0190565b61085191606061084061082e61081c608085015f8701518682035f88015261078a565b6020860151858203602087015261078a565b6040850151848203604086015261078a565b9201519060608184039101526107c8565b90565b9061085e916107f9565b90565b60200190565b9061087b6108748361075f565b8092610763565b908161088c6020830284019461076c565b925f915b83831061089f57505050505090565b909192939460206108c16108bb83856001950387528951610854565b97610861565b9301930191939290610890565b61091d91606060808201926108e95f8201515f850190610745565b6108fb60208201516020850190610745565b61090d60408201516040850190610752565b0151906060818403910152610867565b90565b6109359160208201915f8184039101526108ce565b90565b346109685761096461095361094e3660046105a3565b61229c565b61095b610132565b91829182610920565b0390f35b610138565b3461099d5761097d366004610140565b610999610988612357565b610990610132565b91829182610293565b0390f35b610138565b67ffffffffffffffff81116109c0576109bc60209161030c565b0190565b610316565b906109d76109d2836109a2565b610353565b918252565b5f7f352e302e30000000000000000000000000000000000000000000000000000000910152565b610a0d60056109c5565b90610a1a602083016109dc565b565b610a24610a03565b90565b610a2f610a1c565b90565b610a3a610a27565b90565b60209181520190565b610a65610a6e602093610a7393610a5c816107bb565b93848093610a3d565b9586910161077f565b61030c565b0190565b610a8c9160208201915f818403910152610a46565b90565b34610abf57610a9f366004610140565b610abb610aaa610a32565b610ab2610132565b91829182610a77565b0390f35b610138565b90602082820312610add57610ada915f016102f5565b90565b61013c565b34610b1057610afa610af5366004610ac4565b612645565b610b02610132565b80610b0c81610434565b0390f35b610138565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610b5c575b6020831014610b5757565b610b28565b91607f1691610b4c565b5f5260205f2090565b905f9291805490610b89610b8283610b3c565b8094610776565b916001811690815f14610be05750600114610ba4575b505050565b610bb19192939450610b66565b915f925b818410610bc857505001905f8080610b9f565b60018160209295939554848601520191019290610bb5565b92949550505060ff19168252151560200201905f8080610b9f565b90610c0591610b6f565b90565b90610c28610c2192610c18610132565b93848092610bfb565b038361032a565b565b905f10610c3d57610c3a90610c08565b90565b610b15565b610c4d5f5f90610c2a565b90565b60209181520190565b610c78610c81602093610c8693610c6f81610772565b93848093610c50565b9586910161077f565b61030c565b0190565b610c9f9160208201915f818403910152610c59565b90565b34610cd257610cb2366004610140565b610cce610cbd610c42565b610cc5610132565b91829182610c8a565b0390f35b610138565b34610d0557610cef610cea366004610ac4565b61272a565b610cf7610132565b80610d0181610434565b0390f35b610138565b34610d3857610d22610d1d3660046105a3565b6129eb565b610d2a610132565b80610d3481610434565b0390f35b610138565b34610d6b57610d55610d50366004610ac4565b612a5b565b610d5d610132565b80610d6781610434565b0390f35b610138565b909182601f83011215610daa5781359167ffffffffffffffff8311610da5576020019260018302840111610da057565b6104e4565b6104e0565b610304565b90602082820312610de0575f82013567ffffffffffffffff8111610ddb57610dd79201610d70565b9091565b6102dd565b61013c565b34610e1457610dfe610df8366004610daf565b90612c28565b610e06610132565b80610e1081610434565b0390f35b610138565b5f80fd5b5f90565b610e35610e30610e3a92610698565b6105c1565b61014f565b90565b60a01c90565b610e4f610e5491610e3d565b6101b7565b90565b610e619054610e43565b90565b90565b610e7b610e76610e8092610e64565b6105c1565b61014f565b90565b90565b610e9a610e95610e9f92610e83565b6105c1565b61014f565b90565b634e487b7160e01b5f52601160045260245ffd5b610ec2610ec89161014f565b9161014f565b90039067ffffffffffffffff8211610edc57565b610ea2565b610eea9061014f565b5f8114610ef8576001900390565b610ea2565b610f05610e1d565b50610f0f42610e21565b90610f1a6002610e57565b610f2c610f265f610e67565b9161014f565b148015611015575b610ff957610f55610f456002610e57565b610f4f6001610e86565b90610eb6565b5b80610f72610f6c610f67600361060f565b61014f565b9161014f565b10610ff15782610f9f610f99610f945f610f8e600187906105e0565b01610636565b61014f565b9161014f565b1015610feb5780610fb8610fb25f610e67565b9161014f565b14610fcb57610fc690610ee1565b610f56565b5050505b5f6323788e8160e01b815280610fe760048201610434565b0390fd5b90915090565b505050610fcf565b5f6323788e8160e01b81528061101160048201610434565b0390fd5b50611020600361060f565b61103b6110356110306002610e57565b61014f565b9161014f565b1015610f34565b906110549161104f612c40565b611056565b565b906110699161106481612cf2565b612d68565b565b9061107591611042565b565b5f90565b61108c90611087612e66565b6110df565b90565b90565b5f1b90565b6110ab6110a66110b09261108f565b611092565b610463565b90565b6110dc7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc611097565b90565b506110e86110b3565b90565b6110fb6110f6611077565b61107b565b90565b9061111293929161110d612ec4565b611d8e565b90565b5090565b61112d61112861113292610e64565b6105c1565b610698565b90565b91602061115692949361114f60408201965f83019061015c565b019061015c565b565b6111626080610353565b90565b9061116f9061014f565b9052565b9061117d90610698565b9052565b67ffffffffffffffff81116111995760208091020190565b610316565b5f80fd5b5f80fd5b909291926111bb6111b6826109a2565b610353565b938185526020850190828401116111d7576111d59261038b565b565b610308565b9080601f830112156111fa578160206111f7933591016111a6565b90565b610304565b9190916080818403126112bd576112166080610353565b925f82013567ffffffffffffffff81116112b857816112369184016103cc565b5f850152602082013567ffffffffffffffff81116112b3578161125a9184016103cc565b6020850152604082013567ffffffffffffffff81116112ae578161127f9184016103cc565b6040850152606082013567ffffffffffffffff81116112a9576112a292016111dc565b6060830152565b6111a2565b6111a2565b6111a2565b6111a2565b61119e565b9291906112d66112d182611181565b610353565b938185526020808601920281019183831161132d5781905b8382106112fc575050505050565b813567ffffffffffffffff81116113285760209161131d87849387016111ff565b8152019101906112ee565b610304565b6104e4565b61133d9136916112c2565b90565b52565b61134d905161014f565b90565b9061136367ffffffffffffffff91611092565b9181191691161790565b90565b9061138561138061138c926105c4565b61136d565b8254611350565b9055565b60401b90565b906113b16fffffffffffffffff000000000000000091611390565b9181191691161790565b906113d06113cb6113d7926105c4565b61136d565b8254611396565b9055565b6113e59051610698565b90565b906113f45f1991611092565b9181191691161790565b61141261140d61141792610698565b6105c1565b610698565b90565b90565b9061143261142d611439926113fe565b61141a565b82546113e8565b9055565b5190565b5490565b61145461145a91939293610698565b92610698565b91611466838202610698565b92818404149015171561147557565b610ea2565b611485906004611445565b90565b5f5260205f2090565b906114a4905f19906020036008026101b3565b8154169055565b1b90565b919060086114ca9102916114c45f19846114ab565b926114ab565b9181191691161790565b91906114ea6114e56114f2936113fe565b61141a565b9083546114af565b9055565b5f90565b61150c916115066114f6565b916114d4565b565b5b81811061151a575050565b806115275f6001936114fa565b0161150f565b9061153d905f19906008026101b3565b191690565b8161154c9161152d565b906002021790565b905f9161156b61156382610b66565b928354611542565b905555565b601f602091010490565b919290602082105f146115d357601f84116001146115a35761159d929350611542565b90555b5b565b50906115c96115ce9360016115c06115ba85610b66565b92611570565b8201910161150e565b611554565b6115a0565b5061160a82936115e4600194610b66565b6116036115f085611570565b820192601f861680611615575b50611570565b019061150e565b6002021790556115a1565b61162190888603611491565b5f6115fd565b929091680100000000000000008211611687576020115f1461167857602081105f1461165c5761165691611542565b90555b5b565b60019160ff191661166c84610b66565b55600202019055611659565b6001915060020201905561165a565b610316565b90815461169881610b3c565b908183116116c1575b8183106116af575b50505050565b6116b89361157a565b5f8080806116a9565b6116cd83838387611627565b6116a1565b5f6116dc9161168c565b565b905f036116f0576116ee906116d2565b565b610b15565b5f5260205f2090565b905f9161171561170d826116f5565b928354611542565b905555565b919290602082105f1461177357601f84116001146117435761173d929350611542565b90555b5b565b509061176961176e93600161176061175a856116f5565b92611570565b8201910161150e565b6116fe565b611740565b506117aa82936117846001946116f5565b6117a361179085611570565b820192601f8616806117b5575b50611570565b019061150e565b600202179055611741565b6117c190888603611491565b5f61179d565b929091680100000000000000008211611827576020115f1461181857602081105f146117fc576117f691611542565b90555b5b565b60019160ff191661180c846116f5565b556002020190556117f9565b600191506002020190556117fa565b610316565b90815461183881610b3c565b90818311611861575b81831061184f575b50505050565b6118589361171a565b5f808080611849565b61186d838383876117c7565b611841565b5f61187c9161182c565b565b905f036118905761188e90611872565b565b610b15565b5f60036118c8926118a8838083016116de565b6118b583600183016116de565b6118c283600283016116de565b0161187e565b565b905f036118dc576118da90611895565b565b610b15565b5b8181106118ed575050565b806118fa5f6004936118ca565b016118e2565b909182811061190f575b505050565b61192d6119276119216119389561147a565b9261147a565b92611488565b9182019101906118e1565b5f808061190a565b90680100000000000000008111611969578161195e61196793611441565b90828155611900565b565b610316565b5190565b5190565b9190601f8111611986575b505050565b6119926119b793610b66565b90602061199e84611570565b830193106119bf575b6119b090611570565b019061150e565b5f8080611981565b91506119b0819290506119a7565b906119d781610772565b9067ffffffffffffffff8211611a97576119fb826119f58554610b3c565b85611976565b602090601f8311600114611a2f57918091611a1e935f92611a23575b5050611542565b90555b565b90915001515f80611a17565b601f19831691611a3e85610b66565b925f5b818110611a7f57509160029391856001969410611a65575b50505002019055611a21565b611a75910151601f84169061152d565b90555f8080611a59565b91936020600181928787015181550195019201611a41565b610316565b90611aa6916119cd565b565b5190565b9190601f8111611abc575b505050565b611ac8611aed936116f5565b906020611ad484611570565b83019310611af5575b611ae690611570565b019061150e565b5f8080611ab7565b9150611ae681929050611add565b90611b0d816107bb565b9067ffffffffffffffff8211611bcd57611b3182611b2b8554610b3c565b85611aac565b602090601f8311600114611b6557918091611b54935f92611b59575b5050611542565b90555b565b90915001515f80611b4d565b601f19831691611b74856116f5565b925f5b818110611bb557509160029391856001969410611b9b575b50505002019055611b57565b611bab910151601f84169061152d565b90555f8080611b8f565b91936020600181928787015181550195019201611b77565b610316565b90611bdc91611b03565b565b90611c3b60606003611c4194611c015f8201611bfb5f8801611972565b90611a9c565b611c1a60018201611c1460208801611972565b90611a9c565b611c3360028201611c2d60408801611972565b90611a9c565b019201611aa8565b90611bd2565b565b90611c4d91611bde565b565b611c74611c6e611c5e8461075f565b93611c698585611940565b61076c565b91611488565b5f915b838310611c845750505050565b6004602082611c9d611c9760019561196e565b86611c43565b01920192019190611c77565b90611cb391611c4f565b565b90611d1160606002611d1794611cd85f8201611cd25f8801611343565b90611370565b611cf05f8201611cea60208801611343565b906113bb565b611d0960018201611d03604088016113db565b9061141d565b01920161143d565b90611ca9565b565b90611d2391611cb5565b565b611d2e9061014f565b67ffffffffffffffff8114611d435760010190565b610ea2565b60a01b90565b90611d6467ffffffffffffffff60a01b91611d48565b9181191691161790565b90611d83611d7e611d8a926105c4565b61136d565b8254611d4e565b9055565b91909150611d9d818490611115565b611daf611da95f611119565b91610698565b14611f9357611dbe6002610e57565b611dd0611dca5f610e67565b9161014f565b11611f23575b611de06002610e57565b611dfa611df467ffffffffffffffff61014f565b9161014f565b14611f0757611e4b611e5491611e6e94611e46611e176002610e57565b9592611e3d43919394611e34611e2b611158565b995f8b01611165565b60208901611165565b60408701611173565b611332565b60608301611340565b611e696001611e636002610e57565b906105e0565b611d19565b611e8a611e83611e7e6002610e57565b611d25565b6002611d6e565b611ea7611e976002610e57565b611ea16001610e86565b90610eb6565b611ed17f150aea6b58abe43dc5a19b4c738e682611cb0f8265b89f6d3ff64e100d84777f916105c4565b90611eda610132565b80611ee481610434565b0390a2611f04611ef46002610e57565b611efe6001610e86565b90610eb6565b90565b5f630115b11160e71b815280611f1f60048201610434565b0390fd5b611f555f611f4f6001611f49611f396002610e57565b611f436001610e86565b90610eb6565b906105e0565b01610636565b82611f68611f628361014f565b9161014f565b1115611f745750611dd6565b82611f8f5f92839263eaf639e560e01b845260048401611135565b0390fd5b5f63283601e960e21b815280611fab60048201610434565b0390fd5b90611fc29291611fbd610e1d565b6110fe565b90565b611fcd612f06565b611fd5611fff565b565b611feb611fe6611ff092610e64565b6105c1565b61026f565b90565b611ffc90611fd7565b90565b61201061200b5f611ff3565b612f54565b565b61201a611fc5565b565b6120266080610353565b90565b5f90565b5f90565b606090565b61203e61201c565b9060208080808561204d612029565b815201612058612029565b81520161206361202d565b81520161206e612031565b81525050565b61207c612036565b90565b9061209161208c83611181565b610353565b918252565b52565b905f92918054906120b36120ac83610b3c565b80946107bf565b916001811690815f1461210a57506001146120ce575b505050565b6120db91929394506116f5565b915f925b8184106120f257505001905f80806120c9565b600181602092959395548486015201910192906120df565b92949550505060ff19168252151560200201905f80806120c9565b9061212f91612099565b90565b9061215261214b92612142610132565b93848092612125565b038361032a565b565b52565b6121616080610353565b90565b906121cb6121c26003612175612157565b9461218c6121845f8301610c08565b5f8801612096565b6121a461219b60018301610c08565b60208801612096565b6121bc6121b360028301610c08565b60408801612096565b01612132565b60608401612154565b565b6121d690612164565b90565b906121e382611441565b6121ec8161207f565b926121fa6020850191611488565b5f915b83831061220a5750505050565b6004602060019261221a856121cd565b8152019201920191906121fd565b9061228e612285600261223961201c565b946122506122485f830161060f565b5f8801611165565b61226761225e5f8301610636565b60208801611165565b61227f6122766001830161065a565b60408801611173565b016121d9565b60608401611340565b565b61229990612228565b90565b6122a4612074565b50806122c16122bb6122b6600361060f565b61014f565b9161014f565b108015612302575b6122e3576122db6122e09160016105e0565b612290565b90565b6122fe905f918291637844813360e01b835260048301610169565b0390fd5b506123195f612313600184906105e0565b0161060f565b61232b6123258361014f565b9161014f565b14156122c9565b5f90565b612342612347916105f6565b61022f565b90565b6123549054612336565b90565b61235f612332565b506123725f61236c612fc0565b0161234a565b90565b60ff1690565b61238761238c9161061c565b612375565b90565b612399905461237b565b90565b151590565b6123b56123b06123ba9261026f565b6105c1565b61026f565b90565b6123c6906123a1565b90565b6123d2906123bd565b90565b906123e968ff000000000000000091611390565b9181191691161790565b6123fc9061239c565b90565b90565b9061241761241261241e926123f3565b6123ff565b82546123d5565b9055565b61242b90610e86565b9052565b9190612442905f60208501940190612422565b565b61244c612fe4565b9061246161245b5f840161238f565b1561239c565b9061246d5f840161060f565b8061248061247a5f610e67565b9161014f565b148061259a575b9061249b6124956001610e86565b9161014f565b1480612572575b6124ad90911561239c565b9081612561575b50612545576124dd906124d26124ca6001610e86565b5f8601611370565b82612533575b6125eb565b6124e5575b50565b6124f2905f809101612402565b600161252a7fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d291612521610132565b9182918261242f565b0390a15f6124e2565b61254060015f8601612402565b6124d8565b5f63f92ee8a960e01b81528061255d60048201610434565b0390fd5b61256c91501561239c565b5f6124b4565b506124ad61257f306123c9565b3b61259261258c5f611119565b91610698565b1490506124a2565b5082612487565b906125b260018060a01b0391611092565b9181191691161790565b6125c5906123bd565b90565b90565b906125e06125db6125e7926125bc565b6125c8565b82546125a1565b9055565b806126066126006125fb5f611ff3565b61027a565b9161027a565b1461262957612627906126183361300d565b612620613022565b60026125cb565b565b5f63e6c4247b60e01b81528061264160048201610434565b0390fd5b61264e90612444565b565b6126619061265c612f06565b612663565b565b8061267e6126786126735f611ff3565b61027a565b9161027a565b148015612707575b6126eb57612694600261234a565b61269f8260026125cb565b906126d36126cd7f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a4350936125bc565b916125bc565b916126dc610132565b806126e681610434565b0390a3565b5f63e6c4247b60e01b81528061270360048201610434565b0390fd5b508061272461271e612719600261234a565b61027a565b9161027a565b14612686565b61273390612650565b565b61274690612741612ec4565b612843565b565b604090612771612778949695939661276760608401985f85019061015c565b602083019061015c565b019061015c565b565b90565b61279161278c6127969261277a565b6105c1565b610698565b90565b6127a86127ae91939293610698565b92610698565b82039182116127b957565b610ea2565b5f6127c891611940565b565b905f036127dc576127da906127be565b565b610b15565b5f60026128009282808201556127fa83600183016114fa565b016127ca565b565b905f0361281457612812906127e1565b565b610b15565b61282561282b9161014f565b9161014f565b019067ffffffffffffffff821161283e57565b610ea2565b908161286061285a612855600361060f565b61014f565b9161014f565b1080156129c7575b612993576128896128844261287e61025861277d565b90612799565b610e21565b90612894600361060f565b9261289f600361060f565b5b806128b36128ad8461014f565b9161014f565b11612925576128ce5f6128c8600184906105e0565b01610636565b6128e06128da8661014f565b9161014f565b101561290957612904906128ff5f6128fa600184906105e0565b612802565b611d25565b6128a0565b5f6375b942bb60e01b81528061292160048201610434565b0390fd5b509150916129476129408361293a6001610e86565b90612819565b6003611370565b9061297b6129757fe9050b7442eb674ed5ec7aa7e21455f8b7344e407385c1a810e4ab5c2a0ed8a2936105c4565b916105c4565b91612984610132565b8061298e81610434565b0390a3565b5061299e600361060f565b906129c36129ac6002610e57565b5f93849363190e9f4b60e11b855260048501612748565b0390fd5b50816129e46129de6129d96002610e57565b61014f565b9161014f565b1015612868565b6129f490612735565b565b612a0790612a02612f06565b612a09565b565b80612a24612a1e612a195f611ff3565b61027a565b9161027a565b14612a3457612a3290612f54565b565b612a57612a405f611ff3565b5f918291631e4fbdf760e01b835260048301610293565b0390fd5b612a64906129f6565b565b90612a7891612a73612ec4565b612ba4565b565b612a849054610b3c565b90565b5090565b91612a969082612a87565b9067ffffffffffffffff8211612b5557612aba82612ab48554610b3c565b85611976565b5f90601f8311600114612aed57918091612adc935f92612ae1575b5050611542565b90555b565b90915001355f80612ad5565b601f19831691612afc85610b66565b925f5b818110612b3d57509160029391856001969410612b23575b50505002019055612adf565b612b33910135601f84169061152d565b90555f8080612b17565b91936020600181928787013581550195019201612aff565b610316565b90612b659291612a8b565b565b9190612b8181612b7a81612b8695610c50565b809561038b565b61030c565b0190565b9091612ba19260208301925f818503910152612b67565b90565b612bad5f612a7a565b612bbf612bb95f611119565b91610698565b11612c0c57612bd08183905f612b5a565b907f54482048e83dca0280310b341d9acf236ac8b0ae105dc9621db5715f683a22e791612c07612bfe610132565b92839283612b8a565b0390a1565b5f637e8a432b60e01b815280612c2460048201610434565b0390fd5b90612c3291612a66565b565b612c3d906123bd565b90565b612c4930612c34565b612c7b612c757f000000000000000000000000000000000000000000000000000000000000000061027a565b9161027a565b148015612ca5575b612c8957565b5f63703e46dd60e11b815280612ca160048201610434565b0390fd5b50612cae61302c565b612ce0612cda7f000000000000000000000000000000000000000000000000000000000000000061027a565b9161027a565b1415612c83565b50612cf0612f06565b565b612cfb90612ce7565b565b612d06906123a1565b90565b612d1290612cfd565b90565b612d1e906123bd565b90565b60e01b90565b612d3081610463565b03612d3757565b5f80fd5b90505190612d4882612d27565b565b90602082820312612d6357612d60915f01612d3b565b90565b61013c565b9190612d966020612d80612d7b86612d09565b612d15565b6352d1902d90612d8e610132565b938492612d21565b82528180612da660048201610434565b03915afa80915f92612e36575b50155f14612de7575050906001612dc857505b565b612de3905f918291634c9c8ce360e01b835260048301610293565b0390fd5b9283612e02612dfc612df76110b3565b610463565b91610463565b03612e1757612e12929350613052565b612dc6565b612e32845f918291632a87526960e21b835260048301610473565b0390fd5b612e5891925060203d8111612e5f575b612e50818361032a565b810190612d4a565b905f612db3565b503d612e46565b612e6f30612c34565b612ea1612e9b7f000000000000000000000000000000000000000000000000000000000000000061027a565b9161027a565b03612ea857565b5f63703e46dd60e11b815280612ec060048201610434565b0390fd5b33612ee0612eda612ed5600261234a565b61027a565b9161027a565b03612ee757565b612f02335f918291632a19e83360e01b835260048301610293565b0390fd5b612f0e612357565b612f27612f21612f1c6130db565b61027a565b9161027a565b03612f2e57565b612f50612f396130db565b5f91829163118cdaa760e01b835260048301610293565b0390fd5b612f5c612fc0565b612f74612f6a5f830161234a565b915f8491016125cb565b90612fa8612fa27f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0936125bc565b916125bc565b91612fb1610132565b80612fbb81610434565b0390a3565b7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930090565b612fec613133565b90565b61300090612ffb613147565b613002565b565b61300b906131df565b565b61301690612fef565b565b613020613147565b565b61302a613018565b565b613034612332565b5061304f5f6130496130446110b3565b6131ea565b0161234a565b90565b9061305c826131ed565b816130877fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b916125bc565b90613090610132565b8061309a81610434565b0390a26130a681610772565b6130b86130b25f611119565b91610698565b115f146130cc576130c8916132bd565b505b565b50506130d6613242565b6130ca565b6130e3612332565b503390565b90565b6130ff6130fa613104926130e8565b611092565b610463565b90565b6131307ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a006130eb565b90565b61313b611077565b50613144613107565b90565b6131586131526132f0565b1561239c565b61315e57565b5f631afcd79f60e31b81528061317660048201610434565b0390fd5b61318b90613186613147565b61318d565b565b806131a86131a261319d5f611ff3565b61027a565b9161027a565b146131b8576131b690612f54565b565b6131db6131c45f611ff3565b5f918291631e4fbdf760e01b835260048301610293565b0390fd5b6131e89061317a565b565b90565b803b6132016131fb5f611119565b91610698565b1461322357613221905f61321b6132166110b3565b6131ea565b016125cb565b565b61323e905f918291634c9c8ce360e01b835260048301610293565b0390fd5b3461325561324f5f611119565b91610698565b1161325c57565b5f63b398979f60e01b81528061327460048201610434565b0390fd5b606090565b9061328f61328a83610368565b610353565b918252565b3d5f146132af576132a43d61327d565b903d5f602084013e5b565b6132b7613278565b906132ad565b5f806132e9936132cb613278565b508390602081019051915af4906132e0613294565b9091909161330e565b90565b5f90565b6132f86132ec565b5061330b5f613305612fe4565b0161238f565b90565b906133229061331b613278565b501561239c565b5f1461332e5750613392565b61333782610772565b6133496133435f611119565b91610698565b1480613377575b613358575090565b613373905f918291639996b31560e01b835260048301610293565b0390fd5b50803b61338c6133865f611119565b91610698565b14613350565b61339b81610772565b6133ad6133a75f611119565b91610698565b115f146133bc57602081519101fd5b5f63d6bda27560e01b8152806133d460048201610434565b0390fdfea26469706673582212207833e93a77992454daeb7cc9bec9049b4568617b60ce396a8f79d99c7cf591b764736f6c634300081e0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\x0E\x19V[a\0\x1D_5a\x01,V[\x80c\x0F\x15i\xCB\x14a\x01'W\x80c(\xCEF\x92\x14a\x01\"W\x80cH\x1Cju\x14a\x01\x1DW\x80cO\x1E\xF2\x86\x14a\x01\x18W\x80cR\xD1\x90-\x14a\x01\x13W\x80c[=\x1F\n\x14a\x01\x0EW\x80ci\xF8\xBF\xA8\x14a\x01\tW\x80cqP\x18\xA6\x14a\x01\x04W\x80c\x82L\xD9\xF8\x14a\0\xFFW\x80c\x8D\xA5\xCB[\x14a\0\xFAW\x80c\xAD<\xB1\xCC\x14a\0\xF5W\x80c\xC4\xD6m\xE8\x14a\0\xF0W\x80c\xD0\rZ\\\x14a\0\xEBW\x80c\xD0\xEB\xDB\xE7\x14a\0\xE6W\x80c\xE5\xB5\x16\x06\x14a\0\xE1W\x80c\xF2\xFD\xE3\x8B\x14a\0\xDCWc\xF8@gf\x03a\0\x0EWa\r\xE5V[a\r=V[a\r\nV[a\x0C\xD7V[a\x0C\xA2V[a\n\xE2V[a\n\x8FV[a\tmV[a\t8V[a\x07\x12V[a\x06\xDAV[a\x05mV[a\x04\x88V[a\x049V[a\x02\xA8V[a\x01\xFAV[a\x01~V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\x01JWV[a\x01<V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x01e\x90a\x01OV[\x90RV[\x91\x90a\x01|\x90_` \x85\x01\x94\x01\x90a\x01\\V[V[4a\x01\xAEWa\x01\x8E6`\x04a\x01@V[a\x01\xAAa\x01\x99a\x0E\xFDV[a\x01\xA1a\x012V[\x91\x82\x91\x82a\x01iV[\x03\x90\xF3[a\x018V[\x1C\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x01\xD4\x90`\x08a\x01\xD9\x93\x02a\x01\xB3V[a\x01\xB7V[\x90V[\x90a\x01\xE7\x91Ta\x01\xC4V[\x90V[a\x01\xF7`\x02`\x14\x90a\x01\xDCV[\x90V[4a\x02*Wa\x02\n6`\x04a\x01@V[a\x02&a\x02\x15a\x01\xEAV[a\x02\x1Da\x012V[\x91\x82\x91\x82a\x01iV[\x03\x90\xF3[a\x018V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x02J\x90`\x08a\x02O\x93\x02a\x01\xB3V[a\x02/V[\x90V[\x90a\x02]\x91Ta\x02:V[\x90V[a\x02l`\x02_\x90a\x02RV[\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x02\x83\x90a\x02oV[\x90V[a\x02\x8F\x90a\x02zV[\x90RV[\x91\x90a\x02\xA6\x90_` \x85\x01\x94\x01\x90a\x02\x86V[V[4a\x02\xD8Wa\x02\xB86`\x04a\x01@V[a\x02\xD4a\x02\xC3a\x02`V[a\x02\xCBa\x012V[\x91\x82\x91\x82a\x02\x93V[\x03\x90\xF3[a\x018V[_\x80\xFD[a\x02\xEA\x81a\x02zV[\x03a\x02\xF1WV[_\x80\xFD[\x90P5\x90a\x03\x02\x82a\x02\xE1V[V[_\x80\xFD[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x034\x90a\x03\x0CV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x03NW`@RV[a\x03\x16V[\x90a\x03fa\x03_a\x012V[\x92\x83a\x03*V[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03\x86Wa\x03\x82` \x91a\x03\x0CV[\x01\x90V[a\x03\x16V[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a\x03\xABa\x03\xA6\x82a\x03hV[a\x03SV[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x03\xC7Wa\x03\xC5\x92a\x03\x8BV[V[a\x03\x08V[\x90\x80`\x1F\x83\x01\x12\x15a\x03\xEAW\x81` a\x03\xE7\x935\x91\x01a\x03\x96V[\x90V[a\x03\x04V[\x91\x90\x91`@\x81\x84\x03\x12a\x04/Wa\x04\x08\x83_\x83\x01a\x02\xF5V[\x92` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04*Wa\x04'\x92\x01a\x03\xCCV[\x90V[a\x02\xDDV[a\x01<V[_\x01\x90V[a\x04Ma\x04G6`\x04a\x03\xEFV[\x90a\x10kV[a\x04Ua\x012V[\x80a\x04_\x81a\x044V[\x03\x90\xF3[\x90V[a\x04o\x90a\x04cV[\x90RV[\x91\x90a\x04\x86\x90_` \x85\x01\x94\x01\x90a\x04fV[V[4a\x04\xB8Wa\x04\x986`\x04a\x01@V[a\x04\xB4a\x04\xA3a\x10\xEBV[a\x04\xABa\x012V[\x91\x82\x91\x82a\x04sV[\x03\x90\xF3[a\x018V[a\x04\xC6\x81a\x01OV[\x03a\x04\xCDWV[_\x80\xFD[\x90P5\x90a\x04\xDE\x82a\x04\xBDV[V[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x05\"W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x05\x1DW` \x01\x92` \x83\x02\x84\x01\x11a\x05\x18WV[a\x04\xE4V[a\x04\xE0V[a\x03\x04V[\x91\x90\x91`@\x81\x84\x03\x12a\x05hWa\x05@\x83_\x83\x01a\x04\xD1V[\x92` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x05cWa\x05_\x92\x01a\x04\xE8V[\x90\x91V[a\x02\xDDV[a\x01<V[4a\x05\x9EWa\x05\x9Aa\x05\x89a\x05\x836`\x04a\x05'V[\x91a\x1F\xAFV[a\x05\x91a\x012V[\x91\x82\x91\x82a\x01iV[\x03\x90\xF3[a\x018V[\x90` \x82\x82\x03\x12a\x05\xBCWa\x05\xB9\x91_\x01a\x04\xD1V[\x90V[a\x01<V[\x90V[a\x05\xD8a\x05\xD3a\x05\xDD\x92a\x01OV[a\x05\xC1V[a\x01OV[\x90V[\x90a\x05\xEA\x90a\x05\xC4V[_R` R`@_ \x90V[_\x1C\x90V[a\x06\x07a\x06\x0C\x91a\x05\xF6V[a\x01\xB7V[\x90V[a\x06\x19\x90Ta\x05\xFBV[\x90V[`@\x1C\x90V[a\x06.a\x063\x91a\x06\x1CV[a\x01\xB7V[\x90V[a\x06@\x90Ta\x06\"V[\x90V[\x90V[a\x06Ra\x06W\x91a\x05\xF6V[a\x06CV[\x90V[a\x06d\x90Ta\x06FV[\x90V[a\x06r\x90`\x01a\x05\xE0V[a\x06}_\x82\x01a\x06\x0FV[\x91a\x06\x95`\x01a\x06\x8E_\x85\x01a\x066V[\x93\x01a\x06ZV[\x90V[\x90V[a\x06\xA4\x90a\x06\x98V[\x90RV[`@\x90a\x06\xD1a\x06\xD8\x94\x96\x95\x93\x96a\x06\xC7``\x84\x01\x98_\x85\x01\x90a\x01\\V[` \x83\x01\x90a\x01\\V[\x01\x90a\x06\x9BV[V[4a\x07\rWa\x07\ta\x06\xF5a\x06\xF06`\x04a\x05\xA3V[a\x06gV[a\x07\0\x93\x91\x93a\x012V[\x93\x84\x93\x84a\x06\xA8V[\x03\x90\xF3[a\x018V[4a\x07@Wa\x07\"6`\x04a\x01@V[a\x07*a \x12V[a\x072a\x012V[\x80a\x07<\x81a\x044V[\x03\x90\xF3[a\x018V[a\x07N\x90a\x01OV[\x90RV[a\x07[\x90a\x06\x98V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x07\xA9a\x07\xB2` \x93a\x07\xB7\x93a\x07\xA0\x81a\x07rV[\x93\x84\x80\x93a\x07vV[\x95\x86\x91\x01a\x07\x7FV[a\x03\x0CV[\x01\x90V[Q\x90V[` \x91\x81R\x01\x90V[a\x07\xE7a\x07\xF0` \x93a\x07\xF5\x93a\x07\xDE\x81a\x07\xBBV[\x93\x84\x80\x93a\x07\xBFV[\x95\x86\x91\x01a\x07\x7FV[a\x03\x0CV[\x01\x90V[a\x08Q\x91``a\x08@a\x08.a\x08\x1C`\x80\x85\x01_\x87\x01Q\x86\x82\x03_\x88\x01Ra\x07\x8AV[` \x86\x01Q\x85\x82\x03` \x87\x01Ra\x07\x8AV[`@\x85\x01Q\x84\x82\x03`@\x86\x01Ra\x07\x8AV[\x92\x01Q\x90``\x81\x84\x03\x91\x01Ra\x07\xC8V[\x90V[\x90a\x08^\x91a\x07\xF9V[\x90V[` \x01\x90V[\x90a\x08{a\x08t\x83a\x07_V[\x80\x92a\x07cV[\x90\x81a\x08\x8C` \x83\x02\x84\x01\x94a\x07lV[\x92_\x91[\x83\x83\x10a\x08\x9FWPPPPP\x90V[\x90\x91\x92\x93\x94` a\x08\xC1a\x08\xBB\x83\x85`\x01\x95\x03\x87R\x89Qa\x08TV[\x97a\x08aV[\x93\x01\x93\x01\x91\x93\x92\x90a\x08\x90V[a\t\x1D\x91```\x80\x82\x01\x92a\x08\xE9_\x82\x01Q_\x85\x01\x90a\x07EV[a\x08\xFB` \x82\x01Q` \x85\x01\x90a\x07EV[a\t\r`@\x82\x01Q`@\x85\x01\x90a\x07RV[\x01Q\x90``\x81\x84\x03\x91\x01Ra\x08gV[\x90V[a\t5\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x08\xCEV[\x90V[4a\thWa\tda\tSa\tN6`\x04a\x05\xA3V[a\"\x9CV[a\t[a\x012V[\x91\x82\x91\x82a\t V[\x03\x90\xF3[a\x018V[4a\t\x9DWa\t}6`\x04a\x01@V[a\t\x99a\t\x88a#WV[a\t\x90a\x012V[\x91\x82\x91\x82a\x02\x93V[\x03\x90\xF3[a\x018V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\t\xC0Wa\t\xBC` \x91a\x03\x0CV[\x01\x90V[a\x03\x16V[\x90a\t\xD7a\t\xD2\x83a\t\xA2V[a\x03SV[\x91\x82RV[_\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\n\r`\x05a\t\xC5V[\x90a\n\x1A` \x83\x01a\t\xDCV[V[a\n$a\n\x03V[\x90V[a\n/a\n\x1CV[\x90V[a\n:a\n'V[\x90V[` \x91\x81R\x01\x90V[a\nea\nn` \x93a\ns\x93a\n\\\x81a\x07\xBBV[\x93\x84\x80\x93a\n=V[\x95\x86\x91\x01a\x07\x7FV[a\x03\x0CV[\x01\x90V[a\n\x8C\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\nFV[\x90V[4a\n\xBFWa\n\x9F6`\x04a\x01@V[a\n\xBBa\n\xAAa\n2V[a\n\xB2a\x012V[\x91\x82\x91\x82a\nwV[\x03\x90\xF3[a\x018V[\x90` \x82\x82\x03\x12a\n\xDDWa\n\xDA\x91_\x01a\x02\xF5V[\x90V[a\x01<V[4a\x0B\x10Wa\n\xFAa\n\xF56`\x04a\n\xC4V[a&EV[a\x0B\x02a\x012V[\x80a\x0B\x0C\x81a\x044V[\x03\x90\xF3[a\x018V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x0B\\W[` \x83\x10\x14a\x0BWWV[a\x0B(V[\x91`\x7F\x16\x91a\x0BLV[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0B\x89a\x0B\x82\x83a\x0B<V[\x80\x94a\x07vV[\x91`\x01\x81\x16\x90\x81_\x14a\x0B\xE0WP`\x01\x14a\x0B\xA4W[PPPV[a\x0B\xB1\x91\x92\x93\x94Pa\x0BfV[\x91_\x92[\x81\x84\x10a\x0B\xC8WPP\x01\x90_\x80\x80a\x0B\x9FV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0B\xB5V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0B\x9FV[\x90a\x0C\x05\x91a\x0BoV[\x90V[\x90a\x0C(a\x0C!\x92a\x0C\x18a\x012V[\x93\x84\x80\x92a\x0B\xFBV[\x03\x83a\x03*V[V[\x90_\x10a\x0C=Wa\x0C:\x90a\x0C\x08V[\x90V[a\x0B\x15V[a\x0CM__\x90a\x0C*V[\x90V[` \x91\x81R\x01\x90V[a\x0Cxa\x0C\x81` \x93a\x0C\x86\x93a\x0Co\x81a\x07rV[\x93\x84\x80\x93a\x0CPV[\x95\x86\x91\x01a\x07\x7FV[a\x03\x0CV[\x01\x90V[a\x0C\x9F\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x0CYV[\x90V[4a\x0C\xD2Wa\x0C\xB26`\x04a\x01@V[a\x0C\xCEa\x0C\xBDa\x0CBV[a\x0C\xC5a\x012V[\x91\x82\x91\x82a\x0C\x8AV[\x03\x90\xF3[a\x018V[4a\r\x05Wa\x0C\xEFa\x0C\xEA6`\x04a\n\xC4V[a'*V[a\x0C\xF7a\x012V[\x80a\r\x01\x81a\x044V[\x03\x90\xF3[a\x018V[4a\r8Wa\r\"a\r\x1D6`\x04a\x05\xA3V[a)\xEBV[a\r*a\x012V[\x80a\r4\x81a\x044V[\x03\x90\xF3[a\x018V[4a\rkWa\rUa\rP6`\x04a\n\xC4V[a*[V[a\r]a\x012V[\x80a\rg\x81a\x044V[\x03\x90\xF3[a\x018V[\x90\x91\x82`\x1F\x83\x01\x12\x15a\r\xAAW\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\r\xA5W` \x01\x92`\x01\x83\x02\x84\x01\x11a\r\xA0WV[a\x04\xE4V[a\x04\xE0V[a\x03\x04V[\x90` \x82\x82\x03\x12a\r\xE0W_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\r\xDBWa\r\xD7\x92\x01a\rpV[\x90\x91V[a\x02\xDDV[a\x01<V[4a\x0E\x14Wa\r\xFEa\r\xF86`\x04a\r\xAFV[\x90a,(V[a\x0E\x06a\x012V[\x80a\x0E\x10\x81a\x044V[\x03\x90\xF3[a\x018V[_\x80\xFD[_\x90V[a\x0E5a\x0E0a\x0E:\x92a\x06\x98V[a\x05\xC1V[a\x01OV[\x90V[`\xA0\x1C\x90V[a\x0EOa\x0ET\x91a\x0E=V[a\x01\xB7V[\x90V[a\x0Ea\x90Ta\x0ECV[\x90V[\x90V[a\x0E{a\x0Eva\x0E\x80\x92a\x0EdV[a\x05\xC1V[a\x01OV[\x90V[\x90V[a\x0E\x9Aa\x0E\x95a\x0E\x9F\x92a\x0E\x83V[a\x05\xC1V[a\x01OV[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x0E\xC2a\x0E\xC8\x91a\x01OV[\x91a\x01OV[\x90\x03\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x0E\xDCWV[a\x0E\xA2V[a\x0E\xEA\x90a\x01OV[_\x81\x14a\x0E\xF8W`\x01\x90\x03\x90V[a\x0E\xA2V[a\x0F\x05a\x0E\x1DV[Pa\x0F\x0FBa\x0E!V[\x90a\x0F\x1A`\x02a\x0EWV[a\x0F,a\x0F&_a\x0EgV[\x91a\x01OV[\x14\x80\x15a\x10\x15W[a\x0F\xF9Wa\x0FUa\x0FE`\x02a\x0EWV[a\x0FO`\x01a\x0E\x86V[\x90a\x0E\xB6V[[\x80a\x0Fra\x0Fla\x0Fg`\x03a\x06\x0FV[a\x01OV[\x91a\x01OV[\x10a\x0F\xF1W\x82a\x0F\x9Fa\x0F\x99a\x0F\x94_a\x0F\x8E`\x01\x87\x90a\x05\xE0V[\x01a\x066V[a\x01OV[\x91a\x01OV[\x10\x15a\x0F\xEBW\x80a\x0F\xB8a\x0F\xB2_a\x0EgV[\x91a\x01OV[\x14a\x0F\xCBWa\x0F\xC6\x90a\x0E\xE1V[a\x0FVV[PPP[_c#x\x8E\x81`\xE0\x1B\x81R\x80a\x0F\xE7`\x04\x82\x01a\x044V[\x03\x90\xFD[\x90\x91P\x90V[PPPa\x0F\xCFV[_c#x\x8E\x81`\xE0\x1B\x81R\x80a\x10\x11`\x04\x82\x01a\x044V[\x03\x90\xFD[Pa\x10 `\x03a\x06\x0FV[a\x10;a\x105a\x100`\x02a\x0EWV[a\x01OV[\x91a\x01OV[\x10\x15a\x0F4V[\x90a\x10T\x91a\x10Oa,@V[a\x10VV[V[\x90a\x10i\x91a\x10d\x81a,\xF2V[a-hV[V[\x90a\x10u\x91a\x10BV[V[_\x90V[a\x10\x8C\x90a\x10\x87a.fV[a\x10\xDFV[\x90V[\x90V[_\x1B\x90V[a\x10\xABa\x10\xA6a\x10\xB0\x92a\x10\x8FV[a\x10\x92V[a\x04cV[\x90V[a\x10\xDC\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCa\x10\x97V[\x90V[Pa\x10\xE8a\x10\xB3V[\x90V[a\x10\xFBa\x10\xF6a\x10wV[a\x10{V[\x90V[\x90a\x11\x12\x93\x92\x91a\x11\ra.\xC4V[a\x1D\x8EV[\x90V[P\x90V[a\x11-a\x11(a\x112\x92a\x0EdV[a\x05\xC1V[a\x06\x98V[\x90V[\x91` a\x11V\x92\x94\x93a\x11O`@\x82\x01\x96_\x83\x01\x90a\x01\\V[\x01\x90a\x01\\V[V[a\x11b`\x80a\x03SV[\x90V[\x90a\x11o\x90a\x01OV[\x90RV[\x90a\x11}\x90a\x06\x98V[\x90RV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x11\x99W` \x80\x91\x02\x01\x90V[a\x03\x16V[_\x80\xFD[_\x80\xFD[\x90\x92\x91\x92a\x11\xBBa\x11\xB6\x82a\t\xA2V[a\x03SV[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x11\xD7Wa\x11\xD5\x92a\x03\x8BV[V[a\x03\x08V[\x90\x80`\x1F\x83\x01\x12\x15a\x11\xFAW\x81` a\x11\xF7\x935\x91\x01a\x11\xA6V[\x90V[a\x03\x04V[\x91\x90\x91`\x80\x81\x84\x03\x12a\x12\xBDWa\x12\x16`\x80a\x03SV[\x92_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x12\xB8W\x81a\x126\x91\x84\x01a\x03\xCCV[_\x85\x01R` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x12\xB3W\x81a\x12Z\x91\x84\x01a\x03\xCCV[` \x85\x01R`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x12\xAEW\x81a\x12\x7F\x91\x84\x01a\x03\xCCV[`@\x85\x01R``\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x12\xA9Wa\x12\xA2\x92\x01a\x11\xDCV[``\x83\x01RV[a\x11\xA2V[a\x11\xA2V[a\x11\xA2V[a\x11\xA2V[a\x11\x9EV[\x92\x91\x90a\x12\xD6a\x12\xD1\x82a\x11\x81V[a\x03SV[\x93\x81\x85R` \x80\x86\x01\x92\x02\x81\x01\x91\x83\x83\x11a\x13-W\x81\x90[\x83\x82\x10a\x12\xFCWPPPPPV[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x13(W` \x91a\x13\x1D\x87\x84\x93\x87\x01a\x11\xFFV[\x81R\x01\x91\x01\x90a\x12\xEEV[a\x03\x04V[a\x04\xE4V[a\x13=\x916\x91a\x12\xC2V[\x90V[RV[a\x13M\x90Qa\x01OV[\x90V[\x90a\x13cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x10\x92V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a\x13\x85a\x13\x80a\x13\x8C\x92a\x05\xC4V[a\x13mV[\x82Ta\x13PV[\x90UV[`@\x1B\x90V[\x90a\x13\xB1o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x91a\x13\x90V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x13\xD0a\x13\xCBa\x13\xD7\x92a\x05\xC4V[a\x13mV[\x82Ta\x13\x96V[\x90UV[a\x13\xE5\x90Qa\x06\x98V[\x90V[\x90a\x13\xF4_\x19\x91a\x10\x92V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x14\x12a\x14\ra\x14\x17\x92a\x06\x98V[a\x05\xC1V[a\x06\x98V[\x90V[\x90V[\x90a\x142a\x14-a\x149\x92a\x13\xFEV[a\x14\x1AV[\x82Ta\x13\xE8V[\x90UV[Q\x90V[T\x90V[a\x14Ta\x14Z\x91\x93\x92\x93a\x06\x98V[\x92a\x06\x98V[\x91a\x14f\x83\x82\x02a\x06\x98V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x14uWV[a\x0E\xA2V[a\x14\x85\x90`\x04a\x14EV[\x90V[_R` _ \x90V[\x90a\x14\xA4\x90_\x19\x90` \x03`\x08\x02a\x01\xB3V[\x81T\x16\x90UV[\x1B\x90V[\x91\x90`\x08a\x14\xCA\x91\x02\x91a\x14\xC4_\x19\x84a\x14\xABV[\x92a\x14\xABV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x14\xEAa\x14\xE5a\x14\xF2\x93a\x13\xFEV[a\x14\x1AV[\x90\x83Ta\x14\xAFV[\x90UV[_\x90V[a\x15\x0C\x91a\x15\x06a\x14\xF6V[\x91a\x14\xD4V[V[[\x81\x81\x10a\x15\x1AWPPV[\x80a\x15'_`\x01\x93a\x14\xFAV[\x01a\x15\x0FV[\x90a\x15=\x90_\x19\x90`\x08\x02a\x01\xB3V[\x19\x16\x90V[\x81a\x15L\x91a\x15-V[\x90`\x02\x02\x17\x90V[\x90_\x91a\x15ka\x15c\x82a\x0BfV[\x92\x83Ta\x15BV[\x90UUV[`\x1F` \x91\x01\x04\x90V[\x91\x92\x90` \x82\x10_\x14a\x15\xD3W`\x1F\x84\x11`\x01\x14a\x15\xA3Wa\x15\x9D\x92\x93Pa\x15BV[\x90U[[V[P\x90a\x15\xC9a\x15\xCE\x93`\x01a\x15\xC0a\x15\xBA\x85a\x0BfV[\x92a\x15pV[\x82\x01\x91\x01a\x15\x0EV[a\x15TV[a\x15\xA0V[Pa\x16\n\x82\x93a\x15\xE4`\x01\x94a\x0BfV[a\x16\x03a\x15\xF0\x85a\x15pV[\x82\x01\x92`\x1F\x86\x16\x80a\x16\x15W[Pa\x15pV[\x01\x90a\x15\x0EV[`\x02\x02\x17\x90Ua\x15\xA1V[a\x16!\x90\x88\x86\x03a\x14\x91V[_a\x15\xFDV[\x92\x90\x91h\x01\0\0\0\0\0\0\0\0\x82\x11a\x16\x87W` \x11_\x14a\x16xW` \x81\x10_\x14a\x16\\Wa\x16V\x91a\x15BV[\x90U[[V[`\x01\x91`\xFF\x19\x16a\x16l\x84a\x0BfV[U`\x02\x02\x01\x90Ua\x16YV[`\x01\x91P`\x02\x02\x01\x90Ua\x16ZV[a\x03\x16V[\x90\x81Ta\x16\x98\x81a\x0B<V[\x90\x81\x83\x11a\x16\xC1W[\x81\x83\x10a\x16\xAFW[PPPPV[a\x16\xB8\x93a\x15zV[_\x80\x80\x80a\x16\xA9V[a\x16\xCD\x83\x83\x83\x87a\x16'V[a\x16\xA1V[_a\x16\xDC\x91a\x16\x8CV[V[\x90_\x03a\x16\xF0Wa\x16\xEE\x90a\x16\xD2V[V[a\x0B\x15V[_R` _ \x90V[\x90_\x91a\x17\x15a\x17\r\x82a\x16\xF5V[\x92\x83Ta\x15BV[\x90UUV[\x91\x92\x90` \x82\x10_\x14a\x17sW`\x1F\x84\x11`\x01\x14a\x17CWa\x17=\x92\x93Pa\x15BV[\x90U[[V[P\x90a\x17ia\x17n\x93`\x01a\x17`a\x17Z\x85a\x16\xF5V[\x92a\x15pV[\x82\x01\x91\x01a\x15\x0EV[a\x16\xFEV[a\x17@V[Pa\x17\xAA\x82\x93a\x17\x84`\x01\x94a\x16\xF5V[a\x17\xA3a\x17\x90\x85a\x15pV[\x82\x01\x92`\x1F\x86\x16\x80a\x17\xB5W[Pa\x15pV[\x01\x90a\x15\x0EV[`\x02\x02\x17\x90Ua\x17AV[a\x17\xC1\x90\x88\x86\x03a\x14\x91V[_a\x17\x9DV[\x92\x90\x91h\x01\0\0\0\0\0\0\0\0\x82\x11a\x18'W` \x11_\x14a\x18\x18W` \x81\x10_\x14a\x17\xFCWa\x17\xF6\x91a\x15BV[\x90U[[V[`\x01\x91`\xFF\x19\x16a\x18\x0C\x84a\x16\xF5V[U`\x02\x02\x01\x90Ua\x17\xF9V[`\x01\x91P`\x02\x02\x01\x90Ua\x17\xFAV[a\x03\x16V[\x90\x81Ta\x188\x81a\x0B<V[\x90\x81\x83\x11a\x18aW[\x81\x83\x10a\x18OW[PPPPV[a\x18X\x93a\x17\x1AV[_\x80\x80\x80a\x18IV[a\x18m\x83\x83\x83\x87a\x17\xC7V[a\x18AV[_a\x18|\x91a\x18,V[V[\x90_\x03a\x18\x90Wa\x18\x8E\x90a\x18rV[V[a\x0B\x15V[_`\x03a\x18\xC8\x92a\x18\xA8\x83\x80\x83\x01a\x16\xDEV[a\x18\xB5\x83`\x01\x83\x01a\x16\xDEV[a\x18\xC2\x83`\x02\x83\x01a\x16\xDEV[\x01a\x18~V[V[\x90_\x03a\x18\xDCWa\x18\xDA\x90a\x18\x95V[V[a\x0B\x15V[[\x81\x81\x10a\x18\xEDWPPV[\x80a\x18\xFA_`\x04\x93a\x18\xCAV[\x01a\x18\xE2V[\x90\x91\x82\x81\x10a\x19\x0FW[PPPV[a\x19-a\x19'a\x19!a\x198\x95a\x14zV[\x92a\x14zV[\x92a\x14\x88V[\x91\x82\x01\x91\x01\x90a\x18\xE1V[_\x80\x80a\x19\nV[\x90h\x01\0\0\0\0\0\0\0\0\x81\x11a\x19iW\x81a\x19^a\x19g\x93a\x14AV[\x90\x82\x81Ua\x19\0V[V[a\x03\x16V[Q\x90V[Q\x90V[\x91\x90`\x1F\x81\x11a\x19\x86W[PPPV[a\x19\x92a\x19\xB7\x93a\x0BfV[\x90` a\x19\x9E\x84a\x15pV[\x83\x01\x93\x10a\x19\xBFW[a\x19\xB0\x90a\x15pV[\x01\x90a\x15\x0EV[_\x80\x80a\x19\x81V[\x91Pa\x19\xB0\x81\x92\x90Pa\x19\xA7V[\x90a\x19\xD7\x81a\x07rV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1A\x97Wa\x19\xFB\x82a\x19\xF5\x85Ta\x0B<V[\x85a\x19vV[` \x90`\x1F\x83\x11`\x01\x14a\x1A/W\x91\x80\x91a\x1A\x1E\x93_\x92a\x1A#W[PPa\x15BV[\x90U[V[\x90\x91P\x01Q_\x80a\x1A\x17V[`\x1F\x19\x83\x16\x91a\x1A>\x85a\x0BfV[\x92_[\x81\x81\x10a\x1A\x7FWP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x1AeW[PPP\x02\x01\x90Ua\x1A!V[a\x1Au\x91\x01Q`\x1F\x84\x16\x90a\x15-V[\x90U_\x80\x80a\x1AYV[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x1AAV[a\x03\x16V[\x90a\x1A\xA6\x91a\x19\xCDV[V[Q\x90V[\x91\x90`\x1F\x81\x11a\x1A\xBCW[PPPV[a\x1A\xC8a\x1A\xED\x93a\x16\xF5V[\x90` a\x1A\xD4\x84a\x15pV[\x83\x01\x93\x10a\x1A\xF5W[a\x1A\xE6\x90a\x15pV[\x01\x90a\x15\x0EV[_\x80\x80a\x1A\xB7V[\x91Pa\x1A\xE6\x81\x92\x90Pa\x1A\xDDV[\x90a\x1B\r\x81a\x07\xBBV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1B\xCDWa\x1B1\x82a\x1B+\x85Ta\x0B<V[\x85a\x1A\xACV[` \x90`\x1F\x83\x11`\x01\x14a\x1BeW\x91\x80\x91a\x1BT\x93_\x92a\x1BYW[PPa\x15BV[\x90U[V[\x90\x91P\x01Q_\x80a\x1BMV[`\x1F\x19\x83\x16\x91a\x1Bt\x85a\x16\xF5V[\x92_[\x81\x81\x10a\x1B\xB5WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x1B\x9BW[PPP\x02\x01\x90Ua\x1BWV[a\x1B\xAB\x91\x01Q`\x1F\x84\x16\x90a\x15-V[\x90U_\x80\x80a\x1B\x8FV[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x1BwV[a\x03\x16V[\x90a\x1B\xDC\x91a\x1B\x03V[V[\x90a\x1C;```\x03a\x1CA\x94a\x1C\x01_\x82\x01a\x1B\xFB_\x88\x01a\x19rV[\x90a\x1A\x9CV[a\x1C\x1A`\x01\x82\x01a\x1C\x14` \x88\x01a\x19rV[\x90a\x1A\x9CV[a\x1C3`\x02\x82\x01a\x1C-`@\x88\x01a\x19rV[\x90a\x1A\x9CV[\x01\x92\x01a\x1A\xA8V[\x90a\x1B\xD2V[V[\x90a\x1CM\x91a\x1B\xDEV[V[a\x1Cta\x1Cna\x1C^\x84a\x07_V[\x93a\x1Ci\x85\x85a\x19@V[a\x07lV[\x91a\x14\x88V[_\x91[\x83\x83\x10a\x1C\x84WPPPPV[`\x04` \x82a\x1C\x9Da\x1C\x97`\x01\x95a\x19nV[\x86a\x1CCV[\x01\x92\x01\x92\x01\x91\x90a\x1CwV[\x90a\x1C\xB3\x91a\x1COV[V[\x90a\x1D\x11```\x02a\x1D\x17\x94a\x1C\xD8_\x82\x01a\x1C\xD2_\x88\x01a\x13CV[\x90a\x13pV[a\x1C\xF0_\x82\x01a\x1C\xEA` \x88\x01a\x13CV[\x90a\x13\xBBV[a\x1D\t`\x01\x82\x01a\x1D\x03`@\x88\x01a\x13\xDBV[\x90a\x14\x1DV[\x01\x92\x01a\x14=V[\x90a\x1C\xA9V[V[\x90a\x1D#\x91a\x1C\xB5V[V[a\x1D.\x90a\x01OV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x14a\x1DCW`\x01\x01\x90V[a\x0E\xA2V[`\xA0\x1B\x90V[\x90a\x1Ddg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x91a\x1DHV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x1D\x83a\x1D~a\x1D\x8A\x92a\x05\xC4V[a\x13mV[\x82Ta\x1DNV[\x90UV[\x91\x90\x91Pa\x1D\x9D\x81\x84\x90a\x11\x15V[a\x1D\xAFa\x1D\xA9_a\x11\x19V[\x91a\x06\x98V[\x14a\x1F\x93Wa\x1D\xBE`\x02a\x0EWV[a\x1D\xD0a\x1D\xCA_a\x0EgV[\x91a\x01OV[\x11a\x1F#W[a\x1D\xE0`\x02a\x0EWV[a\x1D\xFAa\x1D\xF4g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x01OV[\x91a\x01OV[\x14a\x1F\x07Wa\x1EKa\x1ET\x91a\x1En\x94a\x1EFa\x1E\x17`\x02a\x0EWV[\x95\x92a\x1E=C\x91\x93\x94a\x1E4a\x1E+a\x11XV[\x99_\x8B\x01a\x11eV[` \x89\x01a\x11eV[`@\x87\x01a\x11sV[a\x132V[``\x83\x01a\x13@V[a\x1Ei`\x01a\x1Ec`\x02a\x0EWV[\x90a\x05\xE0V[a\x1D\x19V[a\x1E\x8Aa\x1E\x83a\x1E~`\x02a\x0EWV[a\x1D%V[`\x02a\x1DnV[a\x1E\xA7a\x1E\x97`\x02a\x0EWV[a\x1E\xA1`\x01a\x0E\x86V[\x90a\x0E\xB6V[a\x1E\xD1\x7F\x15\n\xEAkX\xAB\xE4=\xC5\xA1\x9BLs\x8Eh&\x11\xCB\x0F\x82e\xB8\x9Fm?\xF6N\x10\r\x84w\x7F\x91a\x05\xC4V[\x90a\x1E\xDAa\x012V[\x80a\x1E\xE4\x81a\x044V[\x03\x90\xA2a\x1F\x04a\x1E\xF4`\x02a\x0EWV[a\x1E\xFE`\x01a\x0E\x86V[\x90a\x0E\xB6V[\x90V[_c\x01\x15\xB1\x11`\xE7\x1B\x81R\x80a\x1F\x1F`\x04\x82\x01a\x044V[\x03\x90\xFD[a\x1FU_a\x1FO`\x01a\x1FIa\x1F9`\x02a\x0EWV[a\x1FC`\x01a\x0E\x86V[\x90a\x0E\xB6V[\x90a\x05\xE0V[\x01a\x066V[\x82a\x1Fha\x1Fb\x83a\x01OV[\x91a\x01OV[\x11\x15a\x1FtWPa\x1D\xD6V[\x82a\x1F\x8F_\x92\x83\x92c\xEA\xF69\xE5`\xE0\x1B\x84R`\x04\x84\x01a\x115V[\x03\x90\xFD[_c(6\x01\xE9`\xE2\x1B\x81R\x80a\x1F\xAB`\x04\x82\x01a\x044V[\x03\x90\xFD[\x90a\x1F\xC2\x92\x91a\x1F\xBDa\x0E\x1DV[a\x10\xFEV[\x90V[a\x1F\xCDa/\x06V[a\x1F\xD5a\x1F\xFFV[V[a\x1F\xEBa\x1F\xE6a\x1F\xF0\x92a\x0EdV[a\x05\xC1V[a\x02oV[\x90V[a\x1F\xFC\x90a\x1F\xD7V[\x90V[a \x10a \x0B_a\x1F\xF3V[a/TV[V[a \x1Aa\x1F\xC5V[V[a &`\x80a\x03SV[\x90V[_\x90V[_\x90V[``\x90V[a >a \x1CV[\x90` \x80\x80\x80\x85a Ma )V[\x81R\x01a Xa )V[\x81R\x01a ca -V[\x81R\x01a na 1V[\x81RPPV[a |a 6V[\x90V[\x90a \x91a \x8C\x83a\x11\x81V[a\x03SV[\x91\x82RV[RV[\x90_\x92\x91\x80T\x90a \xB3a \xAC\x83a\x0B<V[\x80\x94a\x07\xBFV[\x91`\x01\x81\x16\x90\x81_\x14a!\nWP`\x01\x14a \xCEW[PPPV[a \xDB\x91\x92\x93\x94Pa\x16\xF5V[\x91_\x92[\x81\x84\x10a \xF2WPP\x01\x90_\x80\x80a \xC9V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a \xDFV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a \xC9V[\x90a!/\x91a \x99V[\x90V[\x90a!Ra!K\x92a!Ba\x012V[\x93\x84\x80\x92a!%V[\x03\x83a\x03*V[V[RV[a!a`\x80a\x03SV[\x90V[\x90a!\xCBa!\xC2`\x03a!ua!WV[\x94a!\x8Ca!\x84_\x83\x01a\x0C\x08V[_\x88\x01a \x96V[a!\xA4a!\x9B`\x01\x83\x01a\x0C\x08V[` \x88\x01a \x96V[a!\xBCa!\xB3`\x02\x83\x01a\x0C\x08V[`@\x88\x01a \x96V[\x01a!2V[``\x84\x01a!TV[V[a!\xD6\x90a!dV[\x90V[\x90a!\xE3\x82a\x14AV[a!\xEC\x81a \x7FV[\x92a!\xFA` \x85\x01\x91a\x14\x88V[_\x91[\x83\x83\x10a\"\nWPPPPV[`\x04` `\x01\x92a\"\x1A\x85a!\xCDV[\x81R\x01\x92\x01\x92\x01\x91\x90a!\xFDV[\x90a\"\x8Ea\"\x85`\x02a\"9a \x1CV[\x94a\"Pa\"H_\x83\x01a\x06\x0FV[_\x88\x01a\x11eV[a\"ga\"^_\x83\x01a\x066V[` \x88\x01a\x11eV[a\"\x7Fa\"v`\x01\x83\x01a\x06ZV[`@\x88\x01a\x11sV[\x01a!\xD9V[``\x84\x01a\x13@V[V[a\"\x99\x90a\"(V[\x90V[a\"\xA4a tV[P\x80a\"\xC1a\"\xBBa\"\xB6`\x03a\x06\x0FV[a\x01OV[\x91a\x01OV[\x10\x80\x15a#\x02W[a\"\xE3Wa\"\xDBa\"\xE0\x91`\x01a\x05\xE0V[a\"\x90V[\x90V[a\"\xFE\x90_\x91\x82\x91cxD\x813`\xE0\x1B\x83R`\x04\x83\x01a\x01iV[\x03\x90\xFD[Pa#\x19_a#\x13`\x01\x84\x90a\x05\xE0V[\x01a\x06\x0FV[a#+a#%\x83a\x01OV[\x91a\x01OV[\x14\x15a\"\xC9V[_\x90V[a#Ba#G\x91a\x05\xF6V[a\x02/V[\x90V[a#T\x90Ta#6V[\x90V[a#_a#2V[Pa#r_a#la/\xC0V[\x01a#JV[\x90V[`\xFF\x16\x90V[a#\x87a#\x8C\x91a\x06\x1CV[a#uV[\x90V[a#\x99\x90Ta#{V[\x90V[\x15\x15\x90V[a#\xB5a#\xB0a#\xBA\x92a\x02oV[a\x05\xC1V[a\x02oV[\x90V[a#\xC6\x90a#\xA1V[\x90V[a#\xD2\x90a#\xBDV[\x90V[\x90a#\xE9h\xFF\0\0\0\0\0\0\0\0\x91a\x13\x90V[\x91\x81\x19\x16\x91\x16\x17\x90V[a#\xFC\x90a#\x9CV[\x90V[\x90V[\x90a$\x17a$\x12a$\x1E\x92a#\xF3V[a#\xFFV[\x82Ta#\xD5V[\x90UV[a$+\x90a\x0E\x86V[\x90RV[\x91\x90a$B\x90_` \x85\x01\x94\x01\x90a$\"V[V[a$La/\xE4V[\x90a$aa$[_\x84\x01a#\x8FV[\x15a#\x9CV[\x90a$m_\x84\x01a\x06\x0FV[\x80a$\x80a$z_a\x0EgV[\x91a\x01OV[\x14\x80a%\x9AW[\x90a$\x9Ba$\x95`\x01a\x0E\x86V[\x91a\x01OV[\x14\x80a%rW[a$\xAD\x90\x91\x15a#\x9CV[\x90\x81a%aW[Pa%EWa$\xDD\x90a$\xD2a$\xCA`\x01a\x0E\x86V[_\x86\x01a\x13pV[\x82a%3W[a%\xEBV[a$\xE5W[PV[a$\xF2\x90_\x80\x91\x01a$\x02V[`\x01a%*\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x91a%!a\x012V[\x91\x82\x91\x82a$/V[\x03\x90\xA1_a$\xE2V[a%@`\x01_\x86\x01a$\x02V[a$\xD8V[_c\xF9.\xE8\xA9`\xE0\x1B\x81R\x80a%]`\x04\x82\x01a\x044V[\x03\x90\xFD[a%l\x91P\x15a#\x9CV[_a$\xB4V[Pa$\xADa%\x7F0a#\xC9V[;a%\x92a%\x8C_a\x11\x19V[\x91a\x06\x98V[\x14\x90Pa$\xA2V[P\x82a$\x87V[\x90a%\xB2`\x01\x80`\xA0\x1B\x03\x91a\x10\x92V[\x91\x81\x19\x16\x91\x16\x17\x90V[a%\xC5\x90a#\xBDV[\x90V[\x90V[\x90a%\xE0a%\xDBa%\xE7\x92a%\xBCV[a%\xC8V[\x82Ta%\xA1V[\x90UV[\x80a&\x06a&\0a%\xFB_a\x1F\xF3V[a\x02zV[\x91a\x02zV[\x14a&)Wa&'\x90a&\x183a0\rV[a& a0\"V[`\x02a%\xCBV[V[_c\xE6\xC4${`\xE0\x1B\x81R\x80a&A`\x04\x82\x01a\x044V[\x03\x90\xFD[a&N\x90a$DV[V[a&a\x90a&\\a/\x06V[a&cV[V[\x80a&~a&xa&s_a\x1F\xF3V[a\x02zV[\x91a\x02zV[\x14\x80\x15a'\x07W[a&\xEBWa&\x94`\x02a#JV[a&\x9F\x82`\x02a%\xCBV[\x90a&\xD3a&\xCD\x7F`\\-\xBFv._}`\xA5F\xD4.r\x05\xDC\xB1\xB0\x11\xEB\xC6*asjW\xC9\x08\x9D:CP\x93a%\xBCV[\x91a%\xBCV[\x91a&\xDCa\x012V[\x80a&\xE6\x81a\x044V[\x03\x90\xA3V[_c\xE6\xC4${`\xE0\x1B\x81R\x80a'\x03`\x04\x82\x01a\x044V[\x03\x90\xFD[P\x80a'$a'\x1Ea'\x19`\x02a#JV[a\x02zV[\x91a\x02zV[\x14a&\x86V[a'3\x90a&PV[V[a'F\x90a'Aa.\xC4V[a(CV[V[`@\x90a'qa'x\x94\x96\x95\x93\x96a'g``\x84\x01\x98_\x85\x01\x90a\x01\\V[` \x83\x01\x90a\x01\\V[\x01\x90a\x01\\V[V[\x90V[a'\x91a'\x8Ca'\x96\x92a'zV[a\x05\xC1V[a\x06\x98V[\x90V[a'\xA8a'\xAE\x91\x93\x92\x93a\x06\x98V[\x92a\x06\x98V[\x82\x03\x91\x82\x11a'\xB9WV[a\x0E\xA2V[_a'\xC8\x91a\x19@V[V[\x90_\x03a'\xDCWa'\xDA\x90a'\xBEV[V[a\x0B\x15V[_`\x02a(\0\x92\x82\x80\x82\x01Ua'\xFA\x83`\x01\x83\x01a\x14\xFAV[\x01a'\xCAV[V[\x90_\x03a(\x14Wa(\x12\x90a'\xE1V[V[a\x0B\x15V[a(%a(+\x91a\x01OV[\x91a\x01OV[\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a(>WV[a\x0E\xA2V[\x90\x81a(`a(Za(U`\x03a\x06\x0FV[a\x01OV[\x91a\x01OV[\x10\x80\x15a)\xC7W[a)\x93Wa(\x89a(\x84Ba(~a\x02Xa'}V[\x90a'\x99V[a\x0E!V[\x90a(\x94`\x03a\x06\x0FV[\x92a(\x9F`\x03a\x06\x0FV[[\x80a(\xB3a(\xAD\x84a\x01OV[\x91a\x01OV[\x11a)%Wa(\xCE_a(\xC8`\x01\x84\x90a\x05\xE0V[\x01a\x066V[a(\xE0a(\xDA\x86a\x01OV[\x91a\x01OV[\x10\x15a)\tWa)\x04\x90a(\xFF_a(\xFA`\x01\x84\x90a\x05\xE0V[a(\x02V[a\x1D%V[a(\xA0V[_cu\xB9B\xBB`\xE0\x1B\x81R\x80a)!`\x04\x82\x01a\x044V[\x03\x90\xFD[P\x91P\x91a)Ga)@\x83a):`\x01a\x0E\x86V[\x90a(\x19V[`\x03a\x13pV[\x90a){a)u\x7F\xE9\x05\x0BtB\xEBgN\xD5\xECz\xA7\xE2\x14U\xF8\xB74N@s\x85\xC1\xA8\x10\xE4\xAB\\*\x0E\xD8\xA2\x93a\x05\xC4V[\x91a\x05\xC4V[\x91a)\x84a\x012V[\x80a)\x8E\x81a\x044V[\x03\x90\xA3V[Pa)\x9E`\x03a\x06\x0FV[\x90a)\xC3a)\xAC`\x02a\x0EWV[_\x93\x84\x93c\x19\x0E\x9FK`\xE1\x1B\x85R`\x04\x85\x01a'HV[\x03\x90\xFD[P\x81a)\xE4a)\xDEa)\xD9`\x02a\x0EWV[a\x01OV[\x91a\x01OV[\x10\x15a(hV[a)\xF4\x90a'5V[V[a*\x07\x90a*\x02a/\x06V[a*\tV[V[\x80a*$a*\x1Ea*\x19_a\x1F\xF3V[a\x02zV[\x91a\x02zV[\x14a*4Wa*2\x90a/TV[V[a*Wa*@_a\x1F\xF3V[_\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[a*d\x90a)\xF6V[V[\x90a*x\x91a*sa.\xC4V[a+\xA4V[V[a*\x84\x90Ta\x0B<V[\x90V[P\x90V[\x91a*\x96\x90\x82a*\x87V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a+UWa*\xBA\x82a*\xB4\x85Ta\x0B<V[\x85a\x19vV[_\x90`\x1F\x83\x11`\x01\x14a*\xEDW\x91\x80\x91a*\xDC\x93_\x92a*\xE1W[PPa\x15BV[\x90U[V[\x90\x91P\x015_\x80a*\xD5V[`\x1F\x19\x83\x16\x91a*\xFC\x85a\x0BfV[\x92_[\x81\x81\x10a+=WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a+#W[PPP\x02\x01\x90Ua*\xDFV[a+3\x91\x015`\x1F\x84\x16\x90a\x15-V[\x90U_\x80\x80a+\x17V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a*\xFFV[a\x03\x16V[\x90a+e\x92\x91a*\x8BV[V[\x91\x90a+\x81\x81a+z\x81a+\x86\x95a\x0CPV[\x80\x95a\x03\x8BV[a\x03\x0CV[\x01\x90V[\x90\x91a+\xA1\x92` \x83\x01\x92_\x81\x85\x03\x91\x01Ra+gV[\x90V[a+\xAD_a*zV[a+\xBFa+\xB9_a\x11\x19V[\x91a\x06\x98V[\x11a,\x0CWa+\xD0\x81\x83\x90_a+ZV[\x90\x7FTH H\xE8=\xCA\x02\x801\x0B4\x1D\x9A\xCF#j\xC8\xB0\xAE\x10]\xC9b\x1D\xB5q_h:\"\xE7\x91a,\x07a+\xFEa\x012V[\x92\x83\x92\x83a+\x8AV[\x03\x90\xA1V[_c~\x8AC+`\xE0\x1B\x81R\x80a,$`\x04\x82\x01a\x044V[\x03\x90\xFD[\x90a,2\x91a*fV[V[a,=\x90a#\xBDV[\x90V[a,I0a,4V[a,{a,u\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x02zV[\x91a\x02zV[\x14\x80\x15a,\xA5W[a,\x89WV[_cp>F\xDD`\xE1\x1B\x81R\x80a,\xA1`\x04\x82\x01a\x044V[\x03\x90\xFD[Pa,\xAEa0,V[a,\xE0a,\xDA\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x02zV[\x91a\x02zV[\x14\x15a,\x83V[Pa,\xF0a/\x06V[V[a,\xFB\x90a,\xE7V[V[a-\x06\x90a#\xA1V[\x90V[a-\x12\x90a,\xFDV[\x90V[a-\x1E\x90a#\xBDV[\x90V[`\xE0\x1B\x90V[a-0\x81a\x04cV[\x03a-7WV[_\x80\xFD[\x90PQ\x90a-H\x82a-'V[V[\x90` \x82\x82\x03\x12a-cWa-`\x91_\x01a-;V[\x90V[a\x01<V[\x91\x90a-\x96` a-\x80a-{\x86a-\tV[a-\x15V[cR\xD1\x90-\x90a-\x8Ea\x012V[\x93\x84\x92a-!V[\x82R\x81\x80a-\xA6`\x04\x82\x01a\x044V[\x03\x91Z\xFA\x80\x91_\x92a.6W[P\x15_\x14a-\xE7WPP\x90`\x01a-\xC8WP[V[a-\xE3\x90_\x91\x82\x91cL\x9C\x8C\xE3`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[\x92\x83a.\x02a-\xFCa-\xF7a\x10\xB3V[a\x04cV[\x91a\x04cV[\x03a.\x17Wa.\x12\x92\x93Pa0RV[a-\xC6V[a.2\x84_\x91\x82\x91c*\x87Ri`\xE2\x1B\x83R`\x04\x83\x01a\x04sV[\x03\x90\xFD[a.X\x91\x92P` =\x81\x11a._W[a.P\x81\x83a\x03*V[\x81\x01\x90a-JV[\x90_a-\xB3V[P=a.FV[a.o0a,4V[a.\xA1a.\x9B\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x02zV[\x91a\x02zV[\x03a.\xA8WV[_cp>F\xDD`\xE1\x1B\x81R\x80a.\xC0`\x04\x82\x01a\x044V[\x03\x90\xFD[3a.\xE0a.\xDAa.\xD5`\x02a#JV[a\x02zV[\x91a\x02zV[\x03a.\xE7WV[a/\x023_\x91\x82\x91c*\x19\xE83`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[a/\x0Ea#WV[a/'a/!a/\x1Ca0\xDBV[a\x02zV[\x91a\x02zV[\x03a/.WV[a/Pa/9a0\xDBV[_\x91\x82\x91c\x11\x8C\xDA\xA7`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[a/\\a/\xC0V[a/ta/j_\x83\x01a#JV[\x91_\x84\x91\x01a%\xCBV[\x90a/\xA8a/\xA2\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x93a%\xBCV[\x91a%\xBCV[\x91a/\xB1a\x012V[\x80a/\xBB\x81a\x044V[\x03\x90\xA3V[\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90V[a/\xECa13V[\x90V[a0\0\x90a/\xFBa1GV[a0\x02V[V[a0\x0B\x90a1\xDFV[V[a0\x16\x90a/\xEFV[V[a0 a1GV[V[a0*a0\x18V[V[a04a#2V[Pa0O_a0Ia0Da\x10\xB3V[a1\xEAV[\x01a#JV[\x90V[\x90a0\\\x82a1\xEDV[\x81a0\x87\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x91a%\xBCV[\x90a0\x90a\x012V[\x80a0\x9A\x81a\x044V[\x03\x90\xA2a0\xA6\x81a\x07rV[a0\xB8a0\xB2_a\x11\x19V[\x91a\x06\x98V[\x11_\x14a0\xCCWa0\xC8\x91a2\xBDV[P[V[PPa0\xD6a2BV[a0\xCAV[a0\xE3a#2V[P3\x90V[\x90V[a0\xFFa0\xFAa1\x04\x92a0\xE8V[a\x10\x92V[a\x04cV[\x90V[a10\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0a0\xEBV[\x90V[a1;a\x10wV[Pa1Da1\x07V[\x90V[a1Xa1Ra2\xF0V[\x15a#\x9CV[a1^WV[_c\x1A\xFC\xD7\x9F`\xE3\x1B\x81R\x80a1v`\x04\x82\x01a\x044V[\x03\x90\xFD[a1\x8B\x90a1\x86a1GV[a1\x8DV[V[\x80a1\xA8a1\xA2a1\x9D_a\x1F\xF3V[a\x02zV[\x91a\x02zV[\x14a1\xB8Wa1\xB6\x90a/TV[V[a1\xDBa1\xC4_a\x1F\xF3V[_\x91\x82\x91c\x1EO\xBD\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[a1\xE8\x90a1zV[V[\x90V[\x80;a2\x01a1\xFB_a\x11\x19V[\x91a\x06\x98V[\x14a2#Wa2!\x90_a2\x1Ba2\x16a\x10\xB3V[a1\xEAV[\x01a%\xCBV[V[a2>\x90_\x91\x82\x91cL\x9C\x8C\xE3`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[4a2Ua2O_a\x11\x19V[\x91a\x06\x98V[\x11a2\\WV[_c\xB3\x98\x97\x9F`\xE0\x1B\x81R\x80a2t`\x04\x82\x01a\x044V[\x03\x90\xFD[``\x90V[\x90a2\x8Fa2\x8A\x83a\x03hV[a\x03SV[\x91\x82RV[=_\x14a2\xAFWa2\xA4=a2}V[\x90=_` \x84\x01>[V[a2\xB7a2xV[\x90a2\xADV[_\x80a2\xE9\x93a2\xCBa2xV[P\x83\x90` \x81\x01\x90Q\x91Z\xF4\x90a2\xE0a2\x94V[\x90\x91\x90\x91a3\x0EV[\x90V[_\x90V[a2\xF8a2\xECV[Pa3\x0B_a3\x05a/\xE4V[\x01a#\x8FV[\x90V[\x90a3\"\x90a3\x1Ba2xV[P\x15a#\x9CV[_\x14a3.WPa3\x92V[a37\x82a\x07rV[a3Ia3C_a\x11\x19V[\x91a\x06\x98V[\x14\x80a3wW[a3XWP\x90V[a3s\x90_\x91\x82\x91c\x99\x96\xB3\x15`\xE0\x1B\x83R`\x04\x83\x01a\x02\x93V[\x03\x90\xFD[P\x80;a3\x8Ca3\x86_a\x11\x19V[\x91a\x06\x98V[\x14a3PV[a3\x9B\x81a\x07rV[a3\xADa3\xA7_a\x11\x19V[\x91a\x06\x98V[\x11_\x14a3\xBCW` \x81Q\x91\x01\xFD[_c\xD6\xBD\xA2u`\xE0\x1B\x81R\x80a3\xD4`\x04\x82\x01a\x044V[\x03\x90\xFD\xFE\xA2dipfsX\"\x12 x3\xE9:w\x99$T\xDA\xEB|\xC9\xBE\xC9\x04\x9BEha{`\xCE9j\x8Fy\xD9\x9C|\xF5\x91\xB7dsolcC\0\x08\x1E\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct Committee { uint64 id; uint64 effectiveTimestamp; uint256 registeredBlockNumber; CommitteeMember[] members; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Committee {
        #[allow(missing_docs)]
        pub id: u64,
        #[allow(missing_docs)]
        pub effectiveTimestamp: u64,
        #[allow(missing_docs)]
        pub registeredBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub members: alloy::sol_types::private::Vec<
            <CommitteeMember as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<CommitteeMember>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            u64,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <CommitteeMember as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Committee> for UnderlyingRustTuple<'_> {
            fn from(value: Committee) -> Self {
                (
                    value.id,
                    value.effectiveTimestamp,
                    value.registeredBlockNumber,
                    value.members,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Committee {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    id: tuple.0,
                    effectiveTimestamp: tuple.1,
                    registeredBlockNumber: tuple.2,
                    members: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Committee {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Committee {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.effectiveTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.registeredBlockNumber,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        CommitteeMember,
                    > as alloy_sol_types::SolType>::tokenize(&self.members),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Committee {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Committee {
            const NAME: &'static str = "Committee";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Committee(uint64 id,uint64 effectiveTimestamp,uint256 registeredBlockNumber,CommitteeMember[] members)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <CommitteeMember as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <CommitteeMember as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.effectiveTimestamp,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.registeredBlockNumber,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        CommitteeMember,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.members)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Committee {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.effectiveTimestamp,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.registeredBlockNumber,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        CommitteeMember,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.members,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.effectiveTimestamp,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.registeredBlockNumber,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    CommitteeMember,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.members,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct CommitteeMember { bytes sigKey; bytes dhKey; bytes dkgKey; string networkAddress; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CommitteeMember {
        #[allow(missing_docs)]
        pub sigKey: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub dhKey: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub dkgKey: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub networkAddress: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CommitteeMember> for UnderlyingRustTuple<'_> {
            fn from(value: CommitteeMember) -> Self {
                (value.sigKey, value.dhKey, value.dkgKey, value.networkAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CommitteeMember {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sigKey: tuple.0,
                    dhKey: tuple.1,
                    dkgKey: tuple.2,
                    networkAddress: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for CommitteeMember {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for CommitteeMember {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sigKey,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.dhKey,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.dkgKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.networkAddress,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for CommitteeMember {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for CommitteeMember {
            const NAME: &'static str = "CommitteeMember";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "CommitteeMember(bytes sigKey,bytes dhKey,bytes dkgKey,string networkAddress)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sigKey,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.dhKey,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.dkgKey,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.networkAddress,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for CommitteeMember {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sigKey,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.dhKey,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.dkgKey,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.networkAddress,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sigKey,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.dhKey,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.dkgKey,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.networkAddress,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CannotRemoveRecentCommittees()` and selector `0x75b942bb`.
```solidity
error CannotRemoveRecentCommittees();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CannotRemoveRecentCommittees;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CannotRemoveRecentCommittees>
        for UnderlyingRustTuple<'_> {
            fn from(value: CannotRemoveRecentCommittees) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CannotRemoveRecentCommittees {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CannotRemoveRecentCommittees {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CannotRemoveRecentCommittees()";
            const SELECTOR: [u8; 4] = [117u8, 185u8, 66u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CommitteeIdDoesNotExist(uint64)` and selector `0x78448133`.
```solidity
error CommitteeIdDoesNotExist(uint64 committeeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CommitteeIdDoesNotExist {
        #[allow(missing_docs)]
        pub committeeId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CommitteeIdDoesNotExist> for UnderlyingRustTuple<'_> {
            fn from(value: CommitteeIdDoesNotExist) -> Self {
                (value.committeeId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CommitteeIdDoesNotExist {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { committeeId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CommitteeIdDoesNotExist {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CommitteeIdDoesNotExist(uint64)";
            const SELECTOR: [u8; 4] = [120u8, 68u8, 129u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.committeeId),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CommitteeIdOverflow()` and selector `0x8ad88880`.
```solidity
error CommitteeIdOverflow();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CommitteeIdOverflow;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CommitteeIdOverflow> for UnderlyingRustTuple<'_> {
            fn from(value: CommitteeIdOverflow) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CommitteeIdOverflow {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CommitteeIdOverflow {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CommitteeIdOverflow()";
            const SELECTOR: [u8; 4] = [138u8, 216u8, 136u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EmptyCommitteeMembers()` and selector `0xa0d807a4`.
```solidity
error EmptyCommitteeMembers();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyCommitteeMembers;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyCommitteeMembers> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyCommitteeMembers) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyCommitteeMembers {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyCommitteeMembers {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyCommitteeMembers()";
            const SELECTOR: [u8; 4] = [160u8, 216u8, 7u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidAddress()` and selector `0xe6c4247b`.
```solidity
error InvalidAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAddress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAddress> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAddress()";
            const SELECTOR: [u8; 4] = [230u8, 196u8, 36u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidEffectiveTimestamp(uint64,uint64)` and selector `0xeaf639e5`.
```solidity
error InvalidEffectiveTimestamp(uint64 effectiveTimestamp, uint64 lastEffectiveTimestamp);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidEffectiveTimestamp {
        #[allow(missing_docs)]
        pub effectiveTimestamp: u64,
        #[allow(missing_docs)]
        pub lastEffectiveTimestamp: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidEffectiveTimestamp>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidEffectiveTimestamp) -> Self {
                (value.effectiveTimestamp, value.lastEffectiveTimestamp)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidEffectiveTimestamp {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    effectiveTimestamp: tuple.0,
                    lastEffectiveTimestamp: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidEffectiveTimestamp {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidEffectiveTimestamp(uint64,uint64)";
            const SELECTOR: [u8; 4] = [234u8, 246u8, 57u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.effectiveTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.lastEffectiveTimestamp,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidPruneRange(uint64,uint64,uint64)` and selector `0x321d3e96`.
```solidity
error InvalidPruneRange(uint64 upToCommitteeId, uint64 oldestStored, uint64 nextCommitteeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidPruneRange {
        #[allow(missing_docs)]
        pub upToCommitteeId: u64,
        #[allow(missing_docs)]
        pub oldestStored: u64,
        #[allow(missing_docs)]
        pub nextCommitteeId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidPruneRange> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidPruneRange) -> Self {
                (value.upToCommitteeId, value.oldestStored, value.nextCommitteeId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidPruneRange {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    upToCommitteeId: tuple.0,
                    oldestStored: tuple.1,
                    nextCommitteeId: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidPruneRange {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidPruneRange(uint64,uint64,uint64)";
            const SELECTOR: [u8; 4] = [50u8, 29u8, 62u8, 150u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.upToCommitteeId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.oldestStored),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nextCommitteeId),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoCommitteeScheduled()` and selector `0x23788e81`.
```solidity
error NoCommitteeScheduled();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoCommitteeScheduled;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoCommitteeScheduled> for UnderlyingRustTuple<'_> {
            fn from(value: NoCommitteeScheduled) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoCommitteeScheduled {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoCommitteeScheduled {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoCommitteeScheduled()";
            const SELECTOR: [u8; 4] = [35u8, 120u8, 142u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotManager(address)` and selector `0x2a19e833`.
```solidity
error NotManager(address caller);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotManager {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotManager> for UnderlyingRustTuple<'_> {
            fn from(value: NotManager) -> Self {
                (value.caller,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotManager {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { caller: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotManager {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotManager(address)";
            const SELECTOR: [u8; 4] = [42u8, 25u8, 232u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ThresholdEncryptionKeyAlreadySet()` and selector `0x7e8a432b`.
```solidity
error ThresholdEncryptionKeyAlreadySet();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ThresholdEncryptionKeyAlreadySet;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ThresholdEncryptionKeyAlreadySet>
        for UnderlyingRustTuple<'_> {
            fn from(value: ThresholdEncryptionKeyAlreadySet) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ThresholdEncryptionKeyAlreadySet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ThresholdEncryptionKeyAlreadySet {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ThresholdEncryptionKeyAlreadySet()";
            const SELECTOR: [u8; 4] = [126u8, 138u8, 67u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `CommitteeCreated(uint64)` and selector `0x150aea6b58abe43dc5a19b4c738e682611cb0f8265b89f6d3ff64e100d84777f`.
```solidity
event CommitteeCreated(uint64 indexed id);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CommitteeCreated {
        #[allow(missing_docs)]
        pub id: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CommitteeCreated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "CommitteeCreated(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                21u8, 10u8, 234u8, 107u8, 88u8, 171u8, 228u8, 61u8, 197u8, 161u8, 155u8,
                76u8, 115u8, 142u8, 104u8, 38u8, 17u8, 203u8, 15u8, 130u8, 101u8, 184u8,
                159u8, 109u8, 63u8, 246u8, 78u8, 16u8, 13u8, 132u8, 119u8, 127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { id: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CommitteeCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CommitteeCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CommitteeCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `CommitteesPruned(uint64,uint64)` and selector `0xe9050b7442eb674ed5ec7aa7e21455f8b7344e407385c1a810e4ab5c2a0ed8a2`.
```solidity
event CommitteesPruned(uint64 indexed fromId, uint64 indexed toId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CommitteesPruned {
        #[allow(missing_docs)]
        pub fromId: u64,
        #[allow(missing_docs)]
        pub toId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CommitteesPruned {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "CommitteesPruned(uint64,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                233u8, 5u8, 11u8, 116u8, 66u8, 235u8, 103u8, 78u8, 213u8, 236u8, 122u8,
                167u8, 226u8, 20u8, 85u8, 248u8, 183u8, 52u8, 78u8, 64u8, 115u8, 133u8,
                193u8, 168u8, 16u8, 228u8, 171u8, 92u8, 42u8, 14u8, 216u8, 162u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    fromId: topics.1,
                    toId: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.fromId.clone(), self.toId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.fromId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.toId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CommitteesPruned {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CommitteesPruned> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CommitteesPruned) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ManagerChanged(address,address)` and selector `0x605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a4350`.
```solidity
event ManagerChanged(address indexed oldManager, address indexed newManager);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ManagerChanged {
        #[allow(missing_docs)]
        pub oldManager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newManager: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ManagerChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ManagerChanged(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                96u8, 92u8, 45u8, 191u8, 118u8, 46u8, 95u8, 125u8, 96u8, 165u8, 70u8,
                212u8, 46u8, 114u8, 5u8, 220u8, 177u8, 176u8, 17u8, 235u8, 198u8, 42u8,
                97u8, 115u8, 106u8, 87u8, 201u8, 8u8, 157u8, 58u8, 67u8, 80u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldManager: topics.1,
                    newManager: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldManager.clone(),
                    self.newManager.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldManager,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newManager,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ManagerChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ManagerChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ManagerChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ThresholdEncryptionKeyUpdated(bytes)` and selector `0x54482048e83dca0280310b341d9acf236ac8b0ae105dc9621db5715f683a22e7`.
```solidity
event ThresholdEncryptionKeyUpdated(bytes thresholdEncryptionKey);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ThresholdEncryptionKeyUpdated {
        #[allow(missing_docs)]
        pub thresholdEncryptionKey: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ThresholdEncryptionKeyUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ThresholdEncryptionKeyUpdated(bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                84u8, 72u8, 32u8, 72u8, 232u8, 61u8, 202u8, 2u8, 128u8, 49u8, 11u8, 52u8,
                29u8, 154u8, 207u8, 35u8, 106u8, 200u8, 176u8, 174u8, 16u8, 93u8, 201u8,
                98u8, 29u8, 181u8, 113u8, 95u8, 104u8, 58u8, 34u8, 231u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    thresholdEncryptionKey: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.thresholdEncryptionKey,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ThresholdEncryptionKeyUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ThresholdEncryptionKeyUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ThresholdEncryptionKeyUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `committees(uint64)` and selector `0x69f8bfa8`.
```solidity
function committees(uint64) external view returns (uint64 id, uint64 effectiveTimestamp, uint256 registeredBlockNumber);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct committeesCall(pub u64);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`committees(uint64)`](committeesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct committeesReturn {
        #[allow(missing_docs)]
        pub id: u64,
        #[allow(missing_docs)]
        pub effectiveTimestamp: u64,
        #[allow(missing_docs)]
        pub registeredBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<committeesCall> for UnderlyingRustTuple<'_> {
                fn from(value: committeesCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for committeesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<committeesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: committeesReturn) -> Self {
                    (value.id, value.effectiveTimestamp, value.registeredBlockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for committeesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        id: tuple.0,
                        effectiveTimestamp: tuple.1,
                        registeredBlockNumber: tuple.2,
                    }
                }
            }
        }
        impl committeesReturn {
            fn _tokenize(
                &self,
            ) -> <committeesCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.effectiveTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.registeredBlockNumber),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for committeesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = committeesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "committees(uint64)";
            const SELECTOR: [u8; 4] = [105u8, 248u8, 191u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                committeesReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `currentCommitteeId()` and selector `0x0f1569cb`.
```solidity
function currentCommitteeId() external view returns (uint64 committeeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentCommitteeIdCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`currentCommitteeId()`](currentCommitteeIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentCommitteeIdReturn {
        #[allow(missing_docs)]
        pub committeeId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentCommitteeIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: currentCommitteeIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for currentCommitteeIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentCommitteeIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: currentCommitteeIdReturn) -> Self {
                    (value.committeeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for currentCommitteeIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { committeeId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentCommitteeIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentCommitteeId()";
            const SELECTOR: [u8; 4] = [15u8, 21u8, 105u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: currentCommitteeIdReturn = r.into();
                        r.committeeId
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: currentCommitteeIdReturn = r.into();
                        r.committeeId
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getCommitteeById(uint64)` and selector `0x824cd9f8`.
```solidity
function getCommitteeById(uint64 id) external view returns (Committee memory committee);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCommitteeByIdCall {
        #[allow(missing_docs)]
        pub id: u64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getCommitteeById(uint64)`](getCommitteeByIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCommitteeByIdReturn {
        #[allow(missing_docs)]
        pub committee: <Committee as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCommitteeByIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCommitteeByIdCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCommitteeByIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Committee,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Committee as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCommitteeByIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCommitteeByIdReturn) -> Self {
                    (value.committee,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCommitteeByIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { committee: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCommitteeByIdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Committee as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Committee,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCommitteeById(uint64)";
            const SELECTOR: [u8; 4] = [130u8, 76u8, 217u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Committee as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getCommitteeByIdReturn = r.into();
                        r.committee
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getCommitteeByIdReturn = r.into();
                        r.committee
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initialize(address)` and selector `0xc4d66de8`.
```solidity
function initialize(address initialManager) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub initialManager: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`initialize(address)`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value.initialManager,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { initialManager: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeReturn {
            fn _tokenize(
                &self,
            ) -> <initializeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address)";
            const SELECTOR: [u8; 4] = [196u8, 214u8, 109u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.initialManager,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `manager()` and selector `0x481c6a75`.
```solidity
function manager() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`manager()`](managerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct managerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerCall> for UnderlyingRustTuple<'_> {
                fn from(value: managerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for managerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<managerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: managerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for managerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for managerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "manager()";
            const SELECTOR: [u8; 4] = [72u8, 28u8, 106u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: managerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: managerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nextCommitteeId()` and selector `0x28ce4692`.
```solidity
function nextCommitteeId() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextCommitteeIdCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nextCommitteeId()`](nextCommitteeIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextCommitteeIdReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextCommitteeIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: nextCommitteeIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nextCommitteeIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextCommitteeIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: nextCommitteeIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nextCommitteeIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nextCommitteeIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nextCommitteeId()";
            const SELECTOR: [u8; 4] = [40u8, 206u8, 70u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nextCommitteeIdReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nextCommitteeIdReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pruneUntil(uint64)` and selector `0xe5b51606`.
```solidity
function pruneUntil(uint64 upToCommitteeId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pruneUntilCall {
        #[allow(missing_docs)]
        pub upToCommitteeId: u64,
    }
    ///Container type for the return parameters of the [`pruneUntil(uint64)`](pruneUntilCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pruneUntilReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pruneUntilCall> for UnderlyingRustTuple<'_> {
                fn from(value: pruneUntilCall) -> Self {
                    (value.upToCommitteeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pruneUntilCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { upToCommitteeId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pruneUntilReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pruneUntilReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pruneUntilReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl pruneUntilReturn {
            fn _tokenize(
                &self,
            ) -> <pruneUntilCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pruneUntilCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pruneUntilReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pruneUntil(uint64)";
            const SELECTOR: [u8; 4] = [229u8, 181u8, 22u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.upToCommitteeId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                pruneUntilReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall;
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <renounceOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setManager(address)` and selector `0xd0ebdbe7`.
```solidity
function setManager(address newManager) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setManagerCall {
        #[allow(missing_docs)]
        pub newManager: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setManager(address)`](setManagerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setManagerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setManagerCall> for UnderlyingRustTuple<'_> {
                fn from(value: setManagerCall) -> Self {
                    (value.newManager,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setManagerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newManager: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setManagerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setManagerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setManagerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setManagerReturn {
            fn _tokenize(
                &self,
            ) -> <setManagerCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setManagerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setManagerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setManager(address)";
            const SELECTOR: [u8; 4] = [208u8, 235u8, 219u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newManager,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setManagerReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setNextCommittee(uint64,(bytes,bytes,bytes,string)[])` and selector `0x5b3d1f0a`.
```solidity
function setNextCommittee(uint64 effectiveTimestamp, CommitteeMember[] memory members) external returns (uint64 committeeId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setNextCommitteeCall {
        #[allow(missing_docs)]
        pub effectiveTimestamp: u64,
        #[allow(missing_docs)]
        pub members: alloy::sol_types::private::Vec<
            <CommitteeMember as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`setNextCommittee(uint64,(bytes,bytes,bytes,string)[])`](setNextCommitteeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setNextCommitteeReturn {
        #[allow(missing_docs)]
        pub committeeId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<CommitteeMember>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::Vec<
                    <CommitteeMember as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setNextCommitteeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setNextCommitteeCall) -> Self {
                    (value.effectiveTimestamp, value.members)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setNextCommitteeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        effectiveTimestamp: tuple.0,
                        members: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setNextCommitteeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setNextCommitteeReturn) -> Self {
                    (value.committeeId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setNextCommitteeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { committeeId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setNextCommitteeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<CommitteeMember>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setNextCommittee(uint64,(bytes,bytes,bytes,string)[])";
            const SELECTOR: [u8; 4] = [91u8, 61u8, 31u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.effectiveTimestamp),
                    <alloy::sol_types::sol_data::Array<
                        CommitteeMember,
                    > as alloy_sol_types::SolType>::tokenize(&self.members),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: setNextCommitteeReturn = r.into();
                        r.committeeId
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: setNextCommitteeReturn = r.into();
                        r.committeeId
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setThresholdEncryptionKey(bytes)` and selector `0xf8406766`.
```solidity
function setThresholdEncryptionKey(bytes memory newThresholdEncryptionKey) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setThresholdEncryptionKeyCall {
        #[allow(missing_docs)]
        pub newThresholdEncryptionKey: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`setThresholdEncryptionKey(bytes)`](setThresholdEncryptionKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setThresholdEncryptionKeyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setThresholdEncryptionKeyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setThresholdEncryptionKeyCall) -> Self {
                    (value.newThresholdEncryptionKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setThresholdEncryptionKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newThresholdEncryptionKey: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setThresholdEncryptionKeyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setThresholdEncryptionKeyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setThresholdEncryptionKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setThresholdEncryptionKeyReturn {
            fn _tokenize(
                &self,
            ) -> <setThresholdEncryptionKeyCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setThresholdEncryptionKeyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setThresholdEncryptionKeyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setThresholdEncryptionKey(bytes)";
            const SELECTOR: [u8; 4] = [248u8, 64u8, 103u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.newThresholdEncryptionKey,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setThresholdEncryptionKeyReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `thresholdEncryptionKey()` and selector `0xd00d5a5c`.
```solidity
function thresholdEncryptionKey() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct thresholdEncryptionKeyCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`thresholdEncryptionKey()`](thresholdEncryptionKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct thresholdEncryptionKeyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<thresholdEncryptionKeyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: thresholdEncryptionKeyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for thresholdEncryptionKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<thresholdEncryptionKeyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: thresholdEncryptionKeyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for thresholdEncryptionKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for thresholdEncryptionKeyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "thresholdEncryptionKey()";
            const SELECTOR: [u8; 4] = [208u8, 13u8, 90u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: thresholdEncryptionKeyReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: thresholdEncryptionKeyReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl transferOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <transferOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                transferOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl upgradeToAndCallReturn {
            fn _tokenize(
                &self,
            ) -> <upgradeToAndCallCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                upgradeToAndCallReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`KeyManager`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum KeyManagerCalls {
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        committees(committeesCall),
        #[allow(missing_docs)]
        currentCommitteeId(currentCommitteeIdCall),
        #[allow(missing_docs)]
        getCommitteeById(getCommitteeByIdCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        manager(managerCall),
        #[allow(missing_docs)]
        nextCommitteeId(nextCommitteeIdCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        pruneUntil(pruneUntilCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        setManager(setManagerCall),
        #[allow(missing_docs)]
        setNextCommittee(setNextCommitteeCall),
        #[allow(missing_docs)]
        setThresholdEncryptionKey(setThresholdEncryptionKeyCall),
        #[allow(missing_docs)]
        thresholdEncryptionKey(thresholdEncryptionKeyCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
    }
    #[automatically_derived]
    impl KeyManagerCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [15u8, 21u8, 105u8, 203u8],
            [40u8, 206u8, 70u8, 146u8],
            [72u8, 28u8, 106u8, 117u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [91u8, 61u8, 31u8, 10u8],
            [105u8, 248u8, 191u8, 168u8],
            [113u8, 80u8, 24u8, 166u8],
            [130u8, 76u8, 217u8, 248u8],
            [141u8, 165u8, 203u8, 91u8],
            [173u8, 60u8, 177u8, 204u8],
            [196u8, 214u8, 109u8, 232u8],
            [208u8, 13u8, 90u8, 92u8],
            [208u8, 235u8, 219u8, 231u8],
            [229u8, 181u8, 22u8, 6u8],
            [242u8, 253u8, 227u8, 139u8],
            [248u8, 64u8, 103u8, 102u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for KeyManagerCalls {
        const NAME: &'static str = "KeyManagerCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 17usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::committees(_) => {
                    <committeesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::currentCommitteeId(_) => {
                    <currentCommitteeIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCommitteeById(_) => {
                    <getCommitteeByIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::manager(_) => <managerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::nextCommitteeId(_) => {
                    <nextCommitteeIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pruneUntil(_) => {
                    <pruneUntilCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setManager(_) => {
                    <setManagerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setNextCommittee(_) => {
                    <setNextCommitteeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setThresholdEncryptionKey(_) => {
                    <setThresholdEncryptionKeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::thresholdEncryptionKey(_) => {
                    <thresholdEncryptionKeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<KeyManagerCalls>] = &[
                {
                    fn currentCommitteeId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <currentCommitteeIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::currentCommitteeId)
                    }
                    currentCommitteeId
                },
                {
                    fn nextCommitteeId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <nextCommitteeIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::nextCommitteeId)
                    }
                    nextCommitteeId
                },
                {
                    fn manager(data: &[u8]) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <managerCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(KeyManagerCalls::manager)
                    }
                    manager
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn setNextCommittee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <setNextCommitteeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::setNextCommittee)
                    }
                    setNextCommittee
                },
                {
                    fn committees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <committeesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::committees)
                    }
                    committees
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn getCommitteeById(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <getCommitteeByIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::getCommitteeById)
                    }
                    getCommitteeById
                },
                {
                    fn owner(data: &[u8]) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(KeyManagerCalls::owner)
                    }
                    owner
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::initialize)
                    }
                    initialize
                },
                {
                    fn thresholdEncryptionKey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <thresholdEncryptionKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::thresholdEncryptionKey)
                    }
                    thresholdEncryptionKey
                },
                {
                    fn setManager(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <setManagerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::setManager)
                    }
                    setManager
                },
                {
                    fn pruneUntil(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <pruneUntilCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::pruneUntil)
                    }
                    pruneUntil
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn setThresholdEncryptionKey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <setThresholdEncryptionKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerCalls::setThresholdEncryptionKey)
                    }
                    setThresholdEncryptionKey
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<KeyManagerCalls>] = &[
                {
                    fn currentCommitteeId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <currentCommitteeIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::currentCommitteeId)
                    }
                    currentCommitteeId
                },
                {
                    fn nextCommitteeId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <nextCommitteeIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::nextCommitteeId)
                    }
                    nextCommitteeId
                },
                {
                    fn manager(data: &[u8]) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <managerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::manager)
                    }
                    manager
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn setNextCommittee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <setNextCommitteeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::setNextCommittee)
                    }
                    setNextCommittee
                },
                {
                    fn committees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <committeesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::committees)
                    }
                    committees
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn getCommitteeById(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <getCommitteeByIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::getCommitteeById)
                    }
                    getCommitteeById
                },
                {
                    fn owner(data: &[u8]) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::owner)
                    }
                    owner
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::initialize)
                    }
                    initialize
                },
                {
                    fn thresholdEncryptionKey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <thresholdEncryptionKeyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::thresholdEncryptionKey)
                    }
                    thresholdEncryptionKey
                },
                {
                    fn setManager(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <setManagerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::setManager)
                    }
                    setManager
                },
                {
                    fn pruneUntil(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <pruneUntilCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::pruneUntil)
                    }
                    pruneUntil
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn setThresholdEncryptionKey(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerCalls> {
                        <setThresholdEncryptionKeyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerCalls::setThresholdEncryptionKey)
                    }
                    setThresholdEncryptionKey
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::committees(inner) => {
                    <committeesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::currentCommitteeId(inner) => {
                    <currentCommitteeIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCommitteeById(inner) => {
                    <getCommitteeByIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::manager(inner) => {
                    <managerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::nextCommitteeId(inner) => {
                    <nextCommitteeIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pruneUntil(inner) => {
                    <pruneUntilCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setManager(inner) => {
                    <setManagerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setNextCommittee(inner) => {
                    <setNextCommitteeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setThresholdEncryptionKey(inner) => {
                    <setThresholdEncryptionKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::thresholdEncryptionKey(inner) => {
                    <thresholdEncryptionKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::committees(inner) => {
                    <committeesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::currentCommitteeId(inner) => {
                    <currentCommitteeIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCommitteeById(inner) => {
                    <getCommitteeByIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::manager(inner) => {
                    <managerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::nextCommitteeId(inner) => {
                    <nextCommitteeIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pruneUntil(inner) => {
                    <pruneUntilCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setManager(inner) => {
                    <setManagerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setNextCommittee(inner) => {
                    <setNextCommitteeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setThresholdEncryptionKey(inner) => {
                    <setThresholdEncryptionKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::thresholdEncryptionKey(inner) => {
                    <thresholdEncryptionKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`KeyManager`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum KeyManagerErrors {
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        CannotRemoveRecentCommittees(CannotRemoveRecentCommittees),
        #[allow(missing_docs)]
        CommitteeIdDoesNotExist(CommitteeIdDoesNotExist),
        #[allow(missing_docs)]
        CommitteeIdOverflow(CommitteeIdOverflow),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        EmptyCommitteeMembers(EmptyCommitteeMembers),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        InvalidAddress(InvalidAddress),
        #[allow(missing_docs)]
        InvalidEffectiveTimestamp(InvalidEffectiveTimestamp),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidPruneRange(InvalidPruneRange),
        #[allow(missing_docs)]
        NoCommitteeScheduled(NoCommitteeScheduled),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotManager(NotManager),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
        #[allow(missing_docs)]
        ThresholdEncryptionKeyAlreadySet(ThresholdEncryptionKeyAlreadySet),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
    }
    #[automatically_derived]
    impl KeyManagerErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [17u8, 140u8, 218u8, 167u8],
            [30u8, 79u8, 189u8, 247u8],
            [35u8, 120u8, 142u8, 129u8],
            [42u8, 25u8, 232u8, 51u8],
            [50u8, 29u8, 62u8, 150u8],
            [76u8, 156u8, 140u8, 227u8],
            [117u8, 185u8, 66u8, 187u8],
            [120u8, 68u8, 129u8, 51u8],
            [126u8, 138u8, 67u8, 43u8],
            [138u8, 216u8, 136u8, 128u8],
            [153u8, 150u8, 179u8, 21u8],
            [160u8, 216u8, 7u8, 164u8],
            [170u8, 29u8, 73u8, 164u8],
            [179u8, 152u8, 151u8, 159u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 230u8, 188u8, 248u8],
            [224u8, 124u8, 141u8, 186u8],
            [230u8, 196u8, 36u8, 123u8],
            [234u8, 246u8, 57u8, 229u8],
            [249u8, 46u8, 232u8, 169u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for KeyManagerErrors {
        const NAME: &'static str = "KeyManagerErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 20usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CannotRemoveRecentCommittees(_) => {
                    <CannotRemoveRecentCommittees as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CommitteeIdDoesNotExist(_) => {
                    <CommitteeIdDoesNotExist as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CommitteeIdOverflow(_) => {
                    <CommitteeIdOverflow as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyCommitteeMembers(_) => {
                    <EmptyCommitteeMembers as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAddress(_) => {
                    <InvalidAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidEffectiveTimestamp(_) => {
                    <InvalidEffectiveTimestamp as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidPruneRange(_) => {
                    <InvalidPruneRange as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoCommitteeScheduled(_) => {
                    <NoCommitteeScheduled as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotManager(_) => {
                    <NotManager as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ThresholdEncryptionKeyAlreadySet(_) => {
                    <ThresholdEncryptionKeyAlreadySet as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<KeyManagerErrors>] = &[
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn NoCommitteeScheduled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <NoCommitteeScheduled as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::NoCommitteeScheduled)
                    }
                    NoCommitteeScheduled
                },
                {
                    fn NotManager(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <NotManager as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(KeyManagerErrors::NotManager)
                    }
                    NotManager
                },
                {
                    fn InvalidPruneRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <InvalidPruneRange as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::InvalidPruneRange)
                    }
                    InvalidPruneRange
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn CannotRemoveRecentCommittees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <CannotRemoveRecentCommittees as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::CannotRemoveRecentCommittees)
                    }
                    CannotRemoveRecentCommittees
                },
                {
                    fn CommitteeIdDoesNotExist(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <CommitteeIdDoesNotExist as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::CommitteeIdDoesNotExist)
                    }
                    CommitteeIdDoesNotExist
                },
                {
                    fn ThresholdEncryptionKeyAlreadySet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <ThresholdEncryptionKeyAlreadySet as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::ThresholdEncryptionKeyAlreadySet)
                    }
                    ThresholdEncryptionKeyAlreadySet
                },
                {
                    fn CommitteeIdOverflow(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <CommitteeIdOverflow as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::CommitteeIdOverflow)
                    }
                    CommitteeIdOverflow
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn EmptyCommitteeMembers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <EmptyCommitteeMembers as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::EmptyCommitteeMembers)
                    }
                    EmptyCommitteeMembers
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(KeyManagerErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <InvalidAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::InvalidAddress)
                    }
                    InvalidAddress
                },
                {
                    fn InvalidEffectiveTimestamp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <InvalidEffectiveTimestamp as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::InvalidEffectiveTimestamp)
                    }
                    InvalidEffectiveTimestamp
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(KeyManagerErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<KeyManagerErrors>] = &[
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn NoCommitteeScheduled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <NoCommitteeScheduled as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::NoCommitteeScheduled)
                    }
                    NoCommitteeScheduled
                },
                {
                    fn NotManager(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <NotManager as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::NotManager)
                    }
                    NotManager
                },
                {
                    fn InvalidPruneRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <InvalidPruneRange as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::InvalidPruneRange)
                    }
                    InvalidPruneRange
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn CannotRemoveRecentCommittees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <CannotRemoveRecentCommittees as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::CannotRemoveRecentCommittees)
                    }
                    CannotRemoveRecentCommittees
                },
                {
                    fn CommitteeIdDoesNotExist(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <CommitteeIdDoesNotExist as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::CommitteeIdDoesNotExist)
                    }
                    CommitteeIdDoesNotExist
                },
                {
                    fn ThresholdEncryptionKeyAlreadySet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <ThresholdEncryptionKeyAlreadySet as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::ThresholdEncryptionKeyAlreadySet)
                    }
                    ThresholdEncryptionKeyAlreadySet
                },
                {
                    fn CommitteeIdOverflow(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <CommitteeIdOverflow as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::CommitteeIdOverflow)
                    }
                    CommitteeIdOverflow
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn EmptyCommitteeMembers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <EmptyCommitteeMembers as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::EmptyCommitteeMembers)
                    }
                    EmptyCommitteeMembers
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <InvalidAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::InvalidAddress)
                    }
                    InvalidAddress
                },
                {
                    fn InvalidEffectiveTimestamp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <InvalidEffectiveTimestamp as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::InvalidEffectiveTimestamp)
                    }
                    InvalidEffectiveTimestamp
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<KeyManagerErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(KeyManagerErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CannotRemoveRecentCommittees(inner) => {
                    <CannotRemoveRecentCommittees as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CommitteeIdDoesNotExist(inner) => {
                    <CommitteeIdDoesNotExist as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CommitteeIdOverflow(inner) => {
                    <CommitteeIdOverflow as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyCommitteeMembers(inner) => {
                    <EmptyCommitteeMembers as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidAddress(inner) => {
                    <InvalidAddress as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidEffectiveTimestamp(inner) => {
                    <InvalidEffectiveTimestamp as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidPruneRange(inner) => {
                    <InvalidPruneRange as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoCommitteeScheduled(inner) => {
                    <NoCommitteeScheduled as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotManager(inner) => {
                    <NotManager as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ThresholdEncryptionKeyAlreadySet(inner) => {
                    <ThresholdEncryptionKeyAlreadySet as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CannotRemoveRecentCommittees(inner) => {
                    <CannotRemoveRecentCommittees as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CommitteeIdDoesNotExist(inner) => {
                    <CommitteeIdDoesNotExist as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CommitteeIdOverflow(inner) => {
                    <CommitteeIdOverflow as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyCommitteeMembers(inner) => {
                    <EmptyCommitteeMembers as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidAddress(inner) => {
                    <InvalidAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidEffectiveTimestamp(inner) => {
                    <InvalidEffectiveTimestamp as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidPruneRange(inner) => {
                    <InvalidPruneRange as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoCommitteeScheduled(inner) => {
                    <NoCommitteeScheduled as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotManager(inner) => {
                    <NotManager as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ThresholdEncryptionKeyAlreadySet(inner) => {
                    <ThresholdEncryptionKeyAlreadySet as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`KeyManager`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum KeyManagerEvents {
        #[allow(missing_docs)]
        CommitteeCreated(CommitteeCreated),
        #[allow(missing_docs)]
        CommitteesPruned(CommitteesPruned),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        ManagerChanged(ManagerChanged),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        ThresholdEncryptionKeyUpdated(ThresholdEncryptionKeyUpdated),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
    }
    #[automatically_derived]
    impl KeyManagerEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                21u8, 10u8, 234u8, 107u8, 88u8, 171u8, 228u8, 61u8, 197u8, 161u8, 155u8,
                76u8, 115u8, 142u8, 104u8, 38u8, 17u8, 203u8, 15u8, 130u8, 101u8, 184u8,
                159u8, 109u8, 63u8, 246u8, 78u8, 16u8, 13u8, 132u8, 119u8, 127u8,
            ],
            [
                84u8, 72u8, 32u8, 72u8, 232u8, 61u8, 202u8, 2u8, 128u8, 49u8, 11u8, 52u8,
                29u8, 154u8, 207u8, 35u8, 106u8, 200u8, 176u8, 174u8, 16u8, 93u8, 201u8,
                98u8, 29u8, 181u8, 113u8, 95u8, 104u8, 58u8, 34u8, 231u8,
            ],
            [
                96u8, 92u8, 45u8, 191u8, 118u8, 46u8, 95u8, 125u8, 96u8, 165u8, 70u8,
                212u8, 46u8, 114u8, 5u8, 220u8, 177u8, 176u8, 17u8, 235u8, 198u8, 42u8,
                97u8, 115u8, 106u8, 87u8, 201u8, 8u8, 157u8, 58u8, 67u8, 80u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                233u8, 5u8, 11u8, 116u8, 66u8, 235u8, 103u8, 78u8, 213u8, 236u8, 122u8,
                167u8, 226u8, 20u8, 85u8, 248u8, 183u8, 52u8, 78u8, 64u8, 115u8, 133u8,
                193u8, 168u8, 16u8, 228u8, 171u8, 92u8, 42u8, 14u8, 216u8, 162u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for KeyManagerEvents {
        const NAME: &'static str = "KeyManagerEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<CommitteeCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <CommitteeCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::CommitteeCreated)
                }
                Some(<CommitteesPruned as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <CommitteesPruned as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::CommitteesPruned)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Initialized)
                }
                Some(<ManagerChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ManagerChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ManagerChanged)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <ThresholdEncryptionKeyUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ThresholdEncryptionKeyUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ThresholdEncryptionKeyUpdated)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Upgraded)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for KeyManagerEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::CommitteeCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CommitteesPruned(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ManagerChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ThresholdEncryptionKeyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::CommitteeCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CommitteesPruned(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ManagerChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ThresholdEncryptionKeyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`KeyManager`](self) contract instance.

See the [wrapper's documentation](`KeyManagerInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> KeyManagerInstance<P, N> {
        KeyManagerInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<KeyManagerInstance<P, N>>,
    > {
        KeyManagerInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        KeyManagerInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`KeyManager`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`KeyManager`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct KeyManagerInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for KeyManagerInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("KeyManagerInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > KeyManagerInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`KeyManager`](self) contract instance.

See the [wrapper's documentation](`KeyManagerInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<KeyManagerInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> KeyManagerInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> KeyManagerInstance<P, N> {
            KeyManagerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > KeyManagerInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall)
        }
        ///Creates a new call builder for the [`committees`] function.
        pub fn committees(
            &self,
            _0: u64,
        ) -> alloy_contract::SolCallBuilder<&P, committeesCall, N> {
            self.call_builder(&committeesCall(_0))
        }
        ///Creates a new call builder for the [`currentCommitteeId`] function.
        pub fn currentCommitteeId(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, currentCommitteeIdCall, N> {
            self.call_builder(&currentCommitteeIdCall)
        }
        ///Creates a new call builder for the [`getCommitteeById`] function.
        pub fn getCommitteeById(
            &self,
            id: u64,
        ) -> alloy_contract::SolCallBuilder<&P, getCommitteeByIdCall, N> {
            self.call_builder(&getCommitteeByIdCall { id })
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            initialManager: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, initializeCall, N> {
            self.call_builder(&initializeCall { initialManager })
        }
        ///Creates a new call builder for the [`manager`] function.
        pub fn manager(&self) -> alloy_contract::SolCallBuilder<&P, managerCall, N> {
            self.call_builder(&managerCall)
        }
        ///Creates a new call builder for the [`nextCommitteeId`] function.
        pub fn nextCommitteeId(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, nextCommitteeIdCall, N> {
            self.call_builder(&nextCommitteeIdCall)
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<&P, ownerCall, N> {
            self.call_builder(&ownerCall)
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall)
        }
        ///Creates a new call builder for the [`pruneUntil`] function.
        pub fn pruneUntil(
            &self,
            upToCommitteeId: u64,
        ) -> alloy_contract::SolCallBuilder<&P, pruneUntilCall, N> {
            self.call_builder(&pruneUntilCall { upToCommitteeId })
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall)
        }
        ///Creates a new call builder for the [`setManager`] function.
        pub fn setManager(
            &self,
            newManager: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setManagerCall, N> {
            self.call_builder(&setManagerCall { newManager })
        }
        ///Creates a new call builder for the [`setNextCommittee`] function.
        pub fn setNextCommittee(
            &self,
            effectiveTimestamp: u64,
            members: alloy::sol_types::private::Vec<
                <CommitteeMember as alloy::sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, setNextCommitteeCall, N> {
            self.call_builder(
                &setNextCommitteeCall {
                    effectiveTimestamp,
                    members,
                },
            )
        }
        ///Creates a new call builder for the [`setThresholdEncryptionKey`] function.
        pub fn setThresholdEncryptionKey(
            &self,
            newThresholdEncryptionKey: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, setThresholdEncryptionKeyCall, N> {
            self.call_builder(
                &setThresholdEncryptionKeyCall {
                    newThresholdEncryptionKey,
                },
            )
        }
        ///Creates a new call builder for the [`thresholdEncryptionKey`] function.
        pub fn thresholdEncryptionKey(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, thresholdEncryptionKeyCall, N> {
            self.call_builder(&thresholdEncryptionKeyCall)
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > KeyManagerInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`CommitteeCreated`] event.
        pub fn CommitteeCreated_filter(
            &self,
        ) -> alloy_contract::Event<&P, CommitteeCreated, N> {
            self.event_filter::<CommitteeCreated>()
        }
        ///Creates a new event filter for the [`CommitteesPruned`] event.
        pub fn CommitteesPruned_filter(
            &self,
        ) -> alloy_contract::Event<&P, CommitteesPruned, N> {
            self.event_filter::<CommitteesPruned>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(&self) -> alloy_contract::Event<&P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`ManagerChanged`] event.
        pub fn ManagerChanged_filter(
            &self,
        ) -> alloy_contract::Event<&P, ManagerChanged, N> {
            self.event_filter::<ManagerChanged>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<&P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`ThresholdEncryptionKeyUpdated`] event.
        pub fn ThresholdEncryptionKeyUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, ThresholdEncryptionKeyUpdated, N> {
            self.event_filter::<ThresholdEncryptionKeyUpdated>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<&P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
    }
}
